<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星图天赋树 - 完美视界版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;400;700&display=swap');

        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #020204;
            color: #e0e0e0;
            overflow: hidden;
            user-select: none;
            width: 100vw;
            height: 100vh;
            margin: 0;
        }

        .magic-font { font-family: 'Cinzel', serif; }

        /* --- 视口容器 --- */
        #viewport {
            width: 100%;
            height: 100%;
            overflow: hidden;
            cursor: grab;
            position: relative;
            background-color: #020204;
        }
        #viewport:active { cursor: grabbing; }

        /* --- 画布内容 --- */
        #canvas-content {
            transform-origin: 0 0;
            will-change: transform;
            position: absolute;
            top: 0; left: 0;
            width: 3000px;
            height: 3000px;
        }

        /* --- 背景 --- */
        #space-background {
            position: absolute;
            width: 100%; height: 100%;
            left: 0; top: 0;
            background-image:
                    radial-gradient(circle at 50% 50%, rgba(20, 20, 35, 0.6) 0%, transparent 80%),
                    radial-gradient(circle at 50% 0%, rgba(249, 115, 22, 0.03) 0%, transparent 50%),
                    radial-gradient(circle at 80% 20%, rgba(34, 211, 238, 0.03) 0%, transparent 40%),
                    radial-gradient(circle at 50% 80%, rgba(203, 213, 225, 0.03) 0%, transparent 40%);
            z-index: 0;
            pointer-events: none;
        }

        #magic-hexagram {
            position: absolute; top: 50%; left: 50%; width: 1600px; height: 1600px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 1;
            opacity: 0.03; fill: none; stroke: url(#hex-gradient); stroke-width: 1;
            animation: rotate-hexagram 300s linear infinite;
        }
        @keyframes rotate-hexagram { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        /* --- 节点基础样式 --- */
        .skill-node {
            position: absolute;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            border-radius: 50%; z-index: 30;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.5s, filter 0.5s;
            background: #0f0f15;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.8);
            /* 默认边框取消，由 SVG 圆环接管 */
            border: none;
        }

        /* 节点图标 */
        .skill-node-icon {
            width: 45%; height: 45%;
            transition: all 0.3s; z-index: 2;
            position: relative;
            /* 默认暗淡 */
            opacity: 0.4;
            filter: grayscale(100%);
        }

        /* --- 动态圆环系统 --- */
        .node-progress-rings {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            transform: rotate(-90deg);
            z-index: 1;
        }

        .prog-ring {
            fill: none;
            stroke: currentColor;
            transition: all 0.5s ease-out;
            opacity: 0; /* 默认隐藏 */
            transform-origin: center;
        }

        /* --- 状态逻辑 (CSS Driven) --- */

        /* 1. Locked (未解锁) */
        .node-locked {
            background: #050505; /* 很黑 */
            box-shadow: inset 0 0 2px rgba(255,255,255,0.1);
            /* 给一个极细的暗边框占位，防止布局跳动，或者用 ring-inset */
            border: 1px solid rgba(255,255,255,0.05);
        }
        .node-locked .skill-node-icon { opacity: 0.2; }

        /* 2. Available (可解锁 - 0/3) */
        .node-available {
            background: #0a0a10;
            cursor: pointer;
            animation: breathe-node 3s infinite alternate;
        }
        .node-available .skill-node-icon { opacity: 0.6; filter: grayscale(50%); }

        /* 虚线圆 */
        .node-available .ring-outer {
            opacity: 0.5;
            stroke-width: 2;
            stroke-dasharray: 4, 4; /* 虚线 */
        }

        /* 3. Level 1 (1/3) */
        .lvl-1 .skill-node-icon { opacity: 1; filter: grayscale(0%); }
        .lvl-1 .ring-outer {
            opacity: 1;
            stroke-width: 3;
            stroke-dasharray: none; /* 实线 */
        }

        /* 4. Level 2 (2/3) */
        .lvl-2 .skill-node-icon { opacity: 1; filter: grayscale(0%); }
        .lvl-2 .ring-outer {
            opacity: 1;
            stroke-width: 3;
            stroke-dasharray: none; /* 外实线 */
        }
        .lvl-2 .ring-mid {
            opacity: 0.6;
            stroke-width: 2;
            stroke-dasharray: 3, 3; /* 内虚线 */
        }

        /* 5. Level 3 (Max) - 金色光晕 */
        .node-maxed .skill-node-icon {
            opacity: 1;
            filter: drop-shadow(0 0 8px #ffd700); /* 金色光晕图标 */
            fill: #fffdf0 !important; /* 接近白色 */
        }
        .node-maxed .ring-outer {
            opacity: 1;
            stroke-width: 3;
            stroke-dasharray: none;
            filter: drop-shadow(0 0 4px currentColor);
        }
        .node-maxed .ring-mid {
            opacity: 1;
            stroke-width: 3;
            stroke-dasharray: none; /* 内实线 */
        }

        /* 隐藏状态 */
        .node-hidden { opacity: 0 !important; pointer-events: none !important; transform: scale(0) !important; }

        /* --- Root Node Special Styles --- */
        .node-root {
            background: none !important;
            box-shadow: none !important;
            border: none !important;
            z-index: 20;
            perspective: 800px;
            overflow: visible !important;
        }
        .root-book-container {
            position: absolute; top: 50%; left: 50%; width: 100%; height: 100%;
            transform-style: preserve-3d;
            transform: translate(-50%, -50%) rotateX(40deg) rotateZ(-5deg);
            transition: transform 0.5s; display: flex; justify-content: center; align-items: center;
        }
        .root-book-icon {
            width: 90% !important; height: 90% !important;
            fill: #555; filter: drop-shadow(0 15px 10px rgba(0,0,0,0.8));
            transition: fill 1s, filter 1s; animation: book-hover 4s infinite alternate ease-in-out;
        }
        .root-rings {
            position: absolute; top: 50%; left: 50%; width: 400%; height: 400%;
            transform: translate(-50%, -50%) rotateX(60deg); pointer-events: none; z-index: -1;
        }
        .root-ring { fill: none; stroke-width: 1; stroke-linecap: round; opacity: 0.1; transition: all 1s; filter: drop-shadow(0 0 0px transparent); }
        .ring-fire-anim { animation: spin-right 60s linear infinite; transform-origin: center; }
        .ring-ice-anim { animation: spin-left 80s linear infinite; transform-origin: center; }
        .ring-phys-anim { animation: spin-right 100s linear infinite; transform-origin: center; }
        @keyframes spin-right { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes spin-left { from { transform: rotate(360deg); } to { transform: rotate(0deg); } }
        @keyframes book-hover { 0% { transform: translateY(0px); } 100% { transform: translateY(-10px); } }

        /* --- 呼吸动画 --- */
        .node-active { animation: breathe-node 4s infinite alternate ease-in-out; }

        .skill-node.is-hovered { z-index: 50; transform: scale(1.2) !important; box-shadow: 0 0 30px currentColor !important; }
        .skill-node.is-dimmed { opacity: 0.1 !important; filter: grayscale(100%) blur(2px) !important; animation: none !important; z-index: 10; }

        @keyframes breathe-node { 0% { transform: scale(1); box-shadow: 0 0 5px currentColor; } 100% { transform: scale(1.05); box-shadow: 0 0 15px currentColor; } }

        /* --- 属性颜色 --- */
        .node-fire { color: #f97316; } .node-fire .skill-node-icon { fill: #c2410c; } .node-fire.node-active .skill-node-icon { fill: #fb923c; }
        .node-ice { color: #22d3ee; } .node-ice .skill-node-icon { fill: #0e7490; } .node-ice.node-active .skill-node-icon { fill: #67e8f9; }
        .node-phys { color: #cbd5e1; } .node-phys .skill-node-icon { fill: #475569; } .node-phys.node-active .skill-node-icon { fill: #e2e8f0; }

        .node-steam { color: #d8b4fe; } .node-steam .skill-node-icon { fill: #9333ea; } .node-steam.node-active .skill-node-icon { fill: #e9d5ff; }
        .node-fracture { color: #2dd4bf; } .node-fracture .skill-node-icon { fill: #0d9488; } .node-fracture.node-active .skill-node-icon { fill: #99f6e4; }
        .node-forge { color: #fbbf24; } .node-forge .skill-node-icon { fill: #b45309; } .node-forge.node-active .skill-node-icon { fill: #fde68a; }
        .node-void { color: #ffffff; } .node-void .skill-node-icon { fill: #555; } .node-void.node-active .skill-node-icon { fill: #fff; }

        /* --- 连接线 --- */
        .connection-line { fill: none; stroke-width: 1.5; stroke-linecap: round; transition: all 0.4s; }
        .line-locked { stroke: rgba(255,255,255,0.08); stroke-dasharray: 4, 8; opacity: 0.3; }
        .line-available { stroke: rgba(255,255,255,0.3); stroke-dasharray: 3, 5; }
        .line-active { stroke-dasharray: none !important; stroke-width: 2; opacity: 0.8; filter: drop-shadow(0 0 3px currentColor); animation: breathe-line 3s infinite alternate ease-in-out; }
        .connection-line.is-dimmed { opacity: 0.05 !important; stroke-width: 1 !important; animation: none !important; }
        .line-hidden { opacity: 0 !important; }
        .line-hybrid { opacity: 0.6; stroke-width: 1; stroke-dasharray: 2, 8; }
        .line-hybrid.line-active { stroke-width: 2; stroke-dasharray: none; animation: flow-dash 1s linear infinite; }
        @keyframes breathe-line { 0% { opacity: 0.6; stroke-width: 2; } 100% { opacity: 1; stroke-width: 3; } }
        @keyframes dash-move { to { stroke-dashoffset: -16; } }
        @keyframes flow-dash { to { stroke-dashoffset: -20; } }
        .connection-line.is-hovered { stroke: rgba(255, 255, 255, 0.8) !important; stroke-dasharray: 4, 4 !important; stroke-width: 2.5 !important; opacity: 1 !important; filter: drop-shadow(0 0 5px white); animation: dash-move 1s linear infinite !important; z-index: 40; }
        .connection-line.line-active.is-hovered { stroke-dasharray: none !important; animation: none !important; filter: drop-shadow(0 0 8px currentColor); }

        /* Line Colors */
        .line-fire { color: #f97316; stroke: #f97316; }
        .line-ice { color: #22d3ee; stroke: #22d3ee; }
        .line-phys { color: #94a3b8; stroke: #94a3b8; }
        .line-steam { color: #d8b4fe; stroke: #d8b4fe; }
        .line-fracture { color: #2dd4bf; stroke: #2dd4bf; }
        .line-forge { color: #fbbf24; stroke: #fbbf24; }
        .line-void { color: #fff; stroke: #fff; }

        #effects-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 25; }
        #tooltip { pointer-events: none; z-index: 100; transition: opacity 0.2s; }

        .constellation-label {
            position: absolute; font-size: 3rem; font-weight: 700; letter-spacing: 0.3em;
            color: rgba(255,255,255,0.04); pointer-events: none;
            font-family: 'Cinzel', serif; transform: translate(-50%, -50%); z-index: 1;
            text-shadow: 0 0 20px rgba(0,0,0,0.5); white-space: nowrap;
            transition: opacity 1s;
        }
        .label-hidden { opacity: 0; }

        .level-badge {
            position: absolute; bottom: -18px; font-size: 9px;
            padding: 0 3px; border-radius: 2px;
            background: #000; border: 1px solid rgba(255,255,255,0.15);
            color: #888; font-family: monospace; pointer-events: none;
        }

        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020204; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; transition: opacity 0.5s;
        }
        .preset-btn { transition: all 0.2s; }
        .preset-btn:active { transform: scale(0.95); }
        .preset-btn:hover { transform: translateY(-1px); }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

<div id="loading-mask">
    <div class="text-amber-500 magic-font text-2xl animate-pulse mb-4">Awakening Grimoire...</div>
    <div class="w-48 h-1 bg-gray-800 rounded overflow-hidden">
        <div id="loading-bar" class="h-full bg-amber-500 w-0 transition-all duration-75"></div>
    </div>
</div>

<header class="fixed top-0 left-0 w-full z-50 px-8 py-6 flex justify-between items-start pointer-events-none">
    <div class="pointer-events-auto">
        <h1 class="text-4xl magic-font text-white font-bold tracking-[0.1em] drop-shadow-[0_0_15px_rgba(255,255,255,0.5)]">
            ASTROLABE
        </h1>
        <p class="text-xs text-blue-200/40 uppercase tracking-[0.4em] mt-1 pl-1">Grimoire of Elements</p>
    </div>
    <div class="flex flex-col items-end pointer-events-auto gap-4">
        <div class="bg-black/60 backdrop-blur-xl border border-white/10 rounded-lg px-6 py-3 flex items-center gap-4 shadow-[0_0_30px_rgba(0,0,0,0.5)]">
            <div class="flex flex-col items-end">
                <span class="text-white/40 text-[10px] uppercase tracking-[0.2em]">Star Dust</span>
                <span id="skill-points-display" class="text-3xl font-bold text-amber-400 magic-font drop-shadow-[0_0_10px_rgba(251,191,36,0.6)]">0</span>
            </div>
            <button onclick="resetTree()" class="w-8 h-8 rounded-full border border-white/10 hover:bg-red-500/20 hover:border-red-500/50 flex items-center justify-center transition-all group" title="Reset All">
                <svg class="w-3 h-3 fill-white/30 group-hover:fill-red-400" viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>
            </button>
        </div>
        <div class="flex gap-2 bg-black/40 backdrop-blur-md p-1.5 rounded-lg border border-white/5">
            <span class="text-[10px] text-white/20 uppercase tracking-widest self-center px-2">Presets:</span>
            <button onclick="applyPreset('fire')" class="preset-btn px-3 py-1.5 rounded border border-orange-500/20 hover:bg-orange-500/20 hover:border-orange-500/50 text-orange-200/70 hover:text-orange-100 text-xs tracking-wider transition-all">Inferno</button>
            <button onclick="applyPreset('ice')" class="preset-btn px-3 py-1.5 rounded border border-cyan-500/20 hover:bg-cyan-500/20 hover:border-cyan-500/50 text-cyan-200/70 hover:text-cyan-100 text-xs tracking-wider transition-all">Glacial</button>
            <button onclick="applyPreset('phys')" class="preset-btn px-3 py-1.5 rounded border border-slate-500/20 hover:bg-slate-500/20 hover:border-slate-500/50 text-slate-200/70 hover:text-slate-100 text-xs tracking-wider transition-all">Titan</button>
            <div class="w-px bg-white/10 mx-1"></div>
            <button onclick="applyPreset('omni')" class="preset-btn px-4 py-1.5 rounded border border-purple-500/30 hover:bg-purple-500/20 hover:border-purple-400/80 text-purple-200 hover:text-white text-xs font-bold tracking-widest transition-all">OMNISCIENCE</button>
        </div>
    </div>
</header>

<div id="viewport">
    <div id="canvas-content" class="absolute top-0 left-0 w-[3000px] h-[3000px] origin-top-left will-change-transform">
        <div id="space-background"></div>
        <svg id="magic-hexagram" viewBox="0 0 100 100">
            <defs>
                <linearGradient id="hex-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#4c1d95" stop-opacity="0.5" />
                    <stop offset="100%" stop-color="#db2777" stop-opacity="0.5" />
                </linearGradient>
            </defs>
            <polygon points="50 5, 90 25, 90 75, 50 95, 10 75, 10 25" fill="none" stroke-width="0.5" />
            <circle cx="50" cy="50" r="35" fill="none" stroke-width="0.2" stroke="rgba(255,255,255,0.2)" />
        </svg>

        <div class="constellation-label" style="left: 50%; top: 20%; color: rgba(249, 115, 22, 0.08);">INFERNO</div>
        <div class="constellation-label" style="left: 80%; top: 75%; color: rgba(34, 211, 238, 0.08);">GLACIAL</div>
        <div class="constellation-label" style="left: 20%; top: 75%; color: rgba(203, 213, 225, 0.08);">TITAN</div>
        <div id="label-steam" class="constellation-label label-hidden" style="left: 80%; top: 35%; font-size: 2rem; color: rgba(216, 180, 254, 0.1);">STEAM</div>
        <div id="label-fracture" class="constellation-label label-hidden" style="left: 50%; top: 85%; font-size: 2rem; color: rgba(94, 234, 212, 0.1);">FRACTURE</div>
        <div id="label-forge" class="constellation-label label-hidden" style="left: 20%; top: 35%; font-size: 2rem; color: rgba(253, 230, 138, 0.1);">FORGE</div>

        <svg id="connections-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 overflow-visible"></svg>
        <canvas id="effects-canvas" width="3000" height="3000"></canvas>
        <div id="skills-layer" class="absolute top-0 left-0 w-full h-full z-30"></div>
    </div>
</div>

<div id="tooltip" class="fixed hidden w-80 bg-[#0a0a0e]/90 backdrop-blur-xl border border-white/15 p-5 shadow-[0_0_50px_rgba(0,0,0,0.8)] text-left z-[100] rounded-lg ring-1 ring-white/10">
    <div class="flex justify-between items-start mb-2">
        <h3 id="tt-name" class="text-lg font-bold text-white magic-font tracking-wide uppercase drop-shadow-md">Name</h3>
        <div id="tt-icon" class="w-6 h-6 opacity-90"></div>
    </div>
    <div class="flex items-center gap-3 mb-3">
        <span id="tt-type" class="text-[9px] font-bold uppercase tracking-widest text-black bg-white/90 px-2 py-0.5 rounded-sm shadow-sm">Passive</span>
        <div class="h-px flex-1 bg-gradient-to-r from-white/20 to-transparent"></div>
        <span id="tt-rank" class="text-xs text-amber-400 font-mono text-shadow">0/3</span>
    </div>
    <p id="tt-desc" class="text-xs text-gray-400 mb-4 leading-relaxed font-light opacity-90">Description...</p>
    <div class="space-y-1 border-t border-white/10 pt-2">
        <div id="tt-next" class="text-[10px] text-emerald-400 font-mono"></div>
        <div id="tt-req" class="text-[10px] text-red-400 font-mono"></div>
    </div>
</div>

<script>
    const CANVAS_SIZE = 3000;
    const CENTER = CANVAS_SIZE / 2;
    const MAX_LEVEL = 3;

    // --- Global Focus State ---
    const focusContext = { active: false, valid: new Set() };

    const TREES = {
        root: { color: '#fbbf24', angle: 0 },
        fire: { color: '#f97316', angle: -90 },
        ice:  { color: '#22d3ee', angle: 30 },
        phys: { color: '#e2e8f0', angle: 150 },
        steam: { color: '#d8b4fe', angle: -30, icons: ['fire_ball', 'ice_crystal'] },
        fracture: { color: '#2dd4bf', angle: 90, icons: ['ice_spike', 'phys_shield'] },
        forge: { color: '#fbbf24', angle: 210, icons: ['phys_axe', 'fire_spark'] },
        void: { color: '#ffffff', angle: 0, icons: ['fire_basic', 'ice_flake', 'phys_sword'] }
    };

    const BASE_SIZE = 40;

    const ICONS = {
        root: 'M3,18 L21,18 L21,6 L3,6 L3,18 Z M3,6 L21,6 L18,4 L6,4 L3,6 Z M12,6 L12,18',
        book_open: 'M12 3c-4.97 0-9 2-9 6v12c0 .55.45 1 1 1h6c1.66 0 3-1.34 3-3V6c0-1.66-1.34-3-3-3zm-1 16H5V9c0-2.76 2.69-4 6-4v14zm10-16c-4.97 0-9 2-9 6v12c0 .55.45 1 1 1h6c1.66 0 3-1.34 3-3V6c0-1.66-1.34-3-3-3zm1 16h-6c-1.66 0-3-1.34-3-3V6c3.31 0 6 1.24 6 4v10z',

        fire_basic: 'M12 23c5.52 0 10-4.48 10-10 0-4-3.25-7.41-7.1-8.93-.56-.22-.59-.98-.05-1.24 2.54-1.22 4.15-3.98 4.15-6.83 0-.55-.45-1-1-1-.34 0-.66.18-.84.47-1.5 2.46-4.31 4.24-7.5 4.5-3.18.26-6.04-1.5-7.57-4.02-.17-.29-.48-.45-.81-.45-.55 0-1 .45-1 1 0 2.85 1.61 5.61 4.15 6.83.54.26.51 1.02-.05 1.24C3.25 5.59 0 9 0 13c0 5.52 4.48 10 10 10s10-4.48 10-10c0-1.85-.51-3.58-1.4-5.06-.47-.78-1.55-.78-2.02 0C15.69 9.42 15.18 11.15 15.18 13c0 1.76-1.42 3.18-3.18 3.18-1.76 0-3.18-1.42-3.18-3.18 0-1.85.51-3.58 1.4-5.06.47-.78-.61-1.78-1.4-1.29C5.33 8.67 3.18 10.67 3.18 13c0 4.86 3.94 8.82 8.82 8.82 4.88 0 8.82-3.96 8.82-8.82 0-.68-.09-1.34-.25-1.98-.24-.96 1.05-1.62 1.68-.84C22.77 11.27 23.18 12.11 23.18 13c0 6.08-4.92 11-11 11z',
        fire_ball: 'M19.48,13.03C19.34,12.85 19.13,12.75 18.9,12.76C18.68,12.78 18.48,12.9 18.37,13.1C17.88,13.94 16.98,14.5 15.95,14.5C15.5,14.5 15.09,14.38 14.71,14.18C15.69,13.56 16.34,12.47 16.34,11.22C16.34,9.41 14.97,7.91 13.21,7.73C13.18,7.73 13.15,7.73 13.12,7.73C13.09,5.87 13.56,4.21 14.24,2.8C14.32,2.63 14.31,2.43 14.21,2.27C14.11,2.11 13.94,2 13.75,2C11.35,2 7.73,5.16 7.73,9.84C7.73,10 7.74,10.15 7.76,10.3C6.06,11.34 5,13.32 5,19.09 7.91,22 11.5,22C14.84,22 17.59,19.49 17.95,16.25C18.67,15.42 19.24,14.33 19.48,13.03M11.5,20.5C8.74,20.5 6.5,18.26 6.5,15.5C6.5,13.71 7.44,12.15 8.87,11.23L9.5,10.82L9.23,10.11C9.22,10.08 9.22,10.05 9.22,10.03C9.24,10.03 9.25,10.04 9.27,10.04C9.29,10.05 9.32,10.06 9.34,10.07C9.54,10.15 9.77,10.19 10,10.19C10.28,10.19 10.54,10.13 10.79,10.03L11.46,9.75L11.55,10.47C11.85,12.83 13.86,14.65 16.28,14.65C16.41,14.65 16.54,14.64 16.66,14.63C16.45,17.93 14.23,20.5 11.5,20.5Z',
        fire_spark: 'M11,21H13V19H11V21M15.14,18.5L16.85,20.2L18.27,18.79L16.56,17.09L15.14,18.5M8.86,18.5L7.44,17.09L5.73,18.79L7.15,20.2L8.86,18.5M12,17C14.21,17 16,15.21 16,13C16,8 12,2 12,2C12,2 8,8 8,13C8,15.21 9.79,17 12,17M12,7.41C13,10.08 14,12.06 14,13C14,14.1 13.1,15 12,15C10.9,15 10,14.1 10,13C10,12.06 11,10.08 12,7.41Z',
        ice_flake: 'M21,11L14.17,11L16.59,8.59L15.17,7.17L12,10.34L8.83,7.17L7.41,8.59L9.83,11L3,11V13L9.83,13L7.41,15.41L8.83,16.83L12,13.66L15.17,16.83L16.59,15.41L14.17,13L21,13V11M12,2L9.17,4.83L10.59,6.24L12,4.83L13.41,6.24L14.83,4.83L12,2M4.83,9.17L2,12L4.83,14.83L6.24,13.41L4.83,12L6.24,10.59L4.83,9.17M19.17,9.17L17.76,10.59L19.17,12L17.76,13.41L19.17,14.83L22,12L19.17,9.17M12,22L14.83,19.17L13.41,17.76L12,19.17L10.59,17.76L9.17,19.17L12,22Z',
        ice_spike: 'M12,2L15,8L21,9L16,14L18,20L12,17L6,20L8,14L3,9L9,8L12,2M12,5.8L10.5,8.8L7.5,9.3L10,11.8L9.2,14.8L12,13.3L14.8,14.8L14,11.8L16.5,9.3L13.5,8.8L12,5.8Z',
        ice_crystal: 'M22,12L17,12L19,10L16,7L12,11L8,7L5,10L7,12L2,12L7,17L5,19L8,22L12,18L16,22L19,19L17,17L22,12M12,15.5L9.5,13L12,10.5L14.5,13L12,15.5Z',
        phys_shield: 'M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z',
        phys_sword: 'M14.5 12.59l.9 3.88-3.92.55 1.56-6.27c.22-.88.18-1.82-.13-2.67C11.8 4.48 8.92 3 5.09 3c-.56 0-1.05.41-1.08.97L4 6l2.05.23c1.15.13 1.9.5 2.27.99.19.25.32.54.39.84l.28.96L7.1 16.1l.89.12L9.86 9.4l1.23 4.94-.57 2.54 4.04-.56 1.07-4.3 1.58.73c1.33.62 1.79 2.22 1.06 3.5l-2.24 3.92c-.48.85-.25 1.93.52 2.5.77.57 1.86.5 2.52-.16l3.12-3.12c.75-.75.96-1.89.51-2.85l-2.71-5.81-5.89-2.73z',
        phys_axe: 'M12 2l-5.5 9h11z M12 22v-8',
        hybrid_dual: 'M6 2l2 6-4 4 6 2-2 6 4-4 6 2-2-6 4-4-6-2 2-6-4 4z',
        hybrid_cloud: 'M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z',
        hybrid_star: 'M12 0l3 9 9 3-9 3-3 9-3-9-9-3 9-3z'
    };

    /* --- 技能数据生成 --- */
    const skillsRaw = [{ id: 'root', tree: 'root', name: 'Grimoire of Origins', icon: 'book_open', type: 'Core', tier: 0, desc: 'The source.' }];
    const mkId = (t, i) => `${t}${i}`;

    function generateTree(treeType, prefixes, iconList, count) {
        let nodes = [];
        const coreId = mkId(treeType.charAt(0), 1);
        nodes.push({ id: coreId, tree: treeType, name: `${prefixes[0]} Core`, icon: iconList[0], tier: 1, req: ['root'], desc: `Tier 1 ${treeType} skill.` });
        let layerPrev = [coreId]; let currentId = 2; const maxTiers = 6;
        for(let t=2; t<=maxTiers; t++) {
            let layerCurrent = []; if(nodes.length >= count) break;
            layerPrev.forEach(parentId => {
                const numChildren = (Math.random() > 0.5 && nodes.length < count - 2) ? 2 : 1;
                for(let c=0; c<numChildren; c++) {
                    if(nodes.length >= count) break;
                    const id = mkId(treeType.charAt(0), currentId++);
                    nodes.push({ id: id, tree: treeType, name: `${prefixes[Math.floor(Math.random()*prefixes.length)]} ${t}-${c}`, icon: iconList[Math.floor(Math.random()*iconList.length)], tier: t, req: [parentId], desc: 'Skill description.' });
                    layerCurrent.push(id);
                }
            });
            layerPrev = layerCurrent;
        }
        return nodes;
    }

    const fireNodes = generateTree('fire', ['Flame', 'Pyro', 'Ash', 'Magma'], ['fire_basic', 'fire_ball', 'fire_spark'], 35);
    const iceNodes = generateTree('ice', ['Frost', 'Cold', 'Ice', 'Snow'], ['ice_flake', 'ice_spike', 'ice_crystal'], 35);
    const physNodes = generateTree('phys', ['Iron', 'Steel', 'War', 'Blood'], ['phys_sword', 'phys_shield', 'phys_axe'], 35);
    skillsRaw.push(...fireNodes, ...iceNodes, ...physNodes);

    function generateHybrids(type, parentTree1, parentTree2, icon, namePrefix) {
        const t1Nodes = skillsRaw.filter(n => n.tree === parentTree1 && n.tier >= 5);
        const t2Nodes = skillsRaw.filter(n => n.tree === parentTree2 && n.tier >= 5);
        if (t1Nodes.length === 0 || t2Nodes.length === 0) return;
        let prefix = type.charAt(0); if(type==='fracture')prefix='fr'; if(type==='forge')prefix='fo'; if(type==='steam')prefix='st';
        let hybrids = []; const count = 8;
        for(let i=0; i<count; i++) {
            const p1 = t1Nodes[Math.floor(Math.random() * t1Nodes.length)];
            const p2 = t2Nodes[Math.floor(Math.random() * t2Nodes.length)];
            const id = mkId(prefix, i + 1);
            let reqs = [p1.id, p2.id]; if (i > 0 && Math.random() > 0.3) reqs = [hybrids[i-1].id, p1.id];
            hybrids.push({ id: id, tree: type, name: `${namePrefix} ${i+1}`, icon: 'special', tier: 99, req: reqs, desc: `Hybrid ${type} skill.` });
        }
        skillsRaw.push(...hybrids);
    }
    generateHybrids('steam', 'fire', 'ice', 'hybrid_cloud', 'Mist');
    generateHybrids('fracture', 'ice', 'phys', 'hybrid_dual', 'Shatter');
    generateHybrids('forge', 'phys', 'fire', 'hybrid_star', 'Molten');

    const lastSteam = skillsRaw.filter(n=>n.tree==='steam').pop();
    const lastFracture = skillsRaw.filter(n=>n.tree==='fracture').pop();
    const lastForge = skillsRaw.filter(n=>n.tree==='forge').pop();
    const voidReqs = [];
    if(lastSteam) voidReqs.push(lastSteam.id); if(lastFracture) voidReqs.push(lastFracture.id); if(lastForge) voidReqs.push(lastForge.id);
    if(voidReqs.length > 0) skillsRaw.push({ id: 'void1', tree: 'void', name: 'Void Singularity', icon: 'special', tier: 100, req: voidReqs, desc: 'Ultimate.' });

    const TOTAL_POINTS = skillsRaw.length * MAX_LEVEL;
    let state = { points: TOTAL_POINTS, skills: { 'root': 1 } };
    skillsRaw.filter(s => s.id !== 'root').forEach(s => state.skills[s.id] = 0);
    let hoveredNodeId = null;
    window.currentRootIntensity = 0;
    let revealAll = false;
    let sys;

    /* --- Simulation --- */
    class Simulation {
        constructor(nodes) {
            this.nodes = nodes.map(n => ({ id: n.id, data: n, x: CENTER, y: CENTER, vx: 0, vy: 0 }));
            this.nodes.forEach(n => {
                if (n.id==='root') { n.x=CENTER; n.y=CENTER; return; }
                const t = n.data.tree;
                let angle = Math.random()*6.28;
                let dist = 200;
                if(['fire','ice','phys'].includes(t)) {
                    const conf = TREES[t];
                    angle = conf.angle * Math.PI/180 + (Math.random()-0.5)*0.5;
                    dist = 200 + Math.random()*200;
                } else {
                    dist = 800 + Math.random()*200;
                    if(t==='steam') angle = -30 * Math.PI/180;
                    if(t==='fracture') angle = 90 * Math.PI/180;
                    if(t==='forge') angle = 210 * Math.PI/180;
                }
                n.x = CENTER + Math.cos(angle)*dist;
                n.y = CENTER + Math.sin(angle)*dist;
            });
            this.links = [];
            this.nodes.forEach(node => {
                if(node.data.req) node.data.req.forEach(pid => {
                    const parent = this.nodes.find(n => n.id === pid);
                    if(parent) this.links.push({ source: parent, target: node });
                });
            });
        }
        tick() {
            const k_repulse = 6000, k_spring = 0.05, k_center = 0.01;
            this.nodes.forEach(n => {
                if(n.id === 'root') { n.x = CENTER; n.y = CENTER; n.vx=0; n.vy=0; return; }
                if (['fire', 'ice', 'phys'].includes(n.data.tree)) {
                    n.vx += (CENTER - n.x) * k_center;
                    n.vy += (CENTER - n.y) * k_center;
                    const dx = n.x - CENTER; const dy = n.y - CENTER; const dist = Math.sqrt(dx*dx + dy*dy);
                    if(dist < 120) { const push = (120 - dist) * 0.1; n.vx += (dx/dist) * push; n.vy += (dy/dist) * push; }
                } else {
                    const dx = n.x - CENTER; const dy = n.y - CENTER; const dist = Math.sqrt(dx*dx + dy*dy);
                    const targetR = 1100;
                    if(dist > 0) {
                        const force = (dist - targetR) * 0.01;
                        n.vx -= (dx/dist) * force;
                        n.vy -= (dy/dist) * force;
                    }
                    if(dist < 900) {
                        const push = (900 - dist) * 0.05;
                        n.vx += (dx/dist) * push;
                        n.vy += (dy/dist) * push;
                    }
                }
            });
            for(let i=0; i<this.nodes.length; i++) {
                for(let j=i+1; j<this.nodes.length; j++) {
                    const a = this.nodes[i], b = this.nodes[j];
                    const dx = a.x - b.x, dy = a.y - b.y, d2 = dx*dx + dy*dy;
                    if(d2 > 0 && d2 < 500000) {
                        const f = k_repulse / d2, fx = (dx/Math.sqrt(d2)) * f, fy = (dy/Math.sqrt(d2)) * f;
                        if(a.id !== 'root') { a.vx += fx; a.vy += fy; }
                        if(b.id !== 'root') { b.vx -= fx; b.vy -= fy; }
                    }
                }
            }
            this.links.forEach(l => {
                const dx = l.target.x - l.source.x, dy = l.target.y - l.source.y, d = Math.sqrt(dx*dx + dy*dy);
                if(d > 0) {
                    let len = 90, k = k_spring;
                    const isHybrid = !['fire','ice','phys','root'].includes(l.target.data.tree);
                    if(isHybrid) { len = 350; k = 0.003; }
                    const f = (d - len) * k, fx = (dx/d) * f, fy = (dy/d) * f;
                    if(l.source.id !== 'root') { l.source.vx += fx; l.source.vy += fy; }
                    if(l.target.id !== 'root') { l.target.vx -= fx; l.target.vy -= fy; }
                }
            });
            this.nodes.forEach(n => { if(n.id !== 'root') { n.x += n.vx; n.y += n.vy; n.vx *= 0.6; n.vy *= 0.6; } });
        }
    }

    const sim = new Simulation(skillsRaw);
    let layoutNodes = [];
    function precomputeLayout() {
        for(let i=0; i<1000; i++) sim.tick();
        layoutNodes = sim.nodes;
        setTimeout(() => {
            document.getElementById('loading-mask').style.opacity = 0;
            setTimeout(() => document.getElementById('loading-mask').style.display = 'none', 500);
            render();
        }, 200);
    }

    /* --- Particle System --- */
    class FlowParticle {
        constructor(sx, sy, tx, ty, color, sId, tId) {
            this.x=sx; this.y=sy; this.sx=sx; this.sy=sy; this.tx=tx; this.ty=ty;
            this.color=color; this.p=0; this.life=1; this.sp=0.01+Math.random()*0.005;
            this.edgeKey = `${sId}-${tId}`;
        }
        update() { this.p+=this.sp; this.x=this.sx+(this.tx-this.sx)*this.p; this.y=this.sy+(this.ty-this.sy)*this.p; if(this.p>=1)this.life=0; }
        draw(ctx) {
            if(focusContext.active && !focusContext.valid.has(this.edgeKey)) ctx.globalAlpha=0.02;
            else ctx.globalAlpha=0.9;
            ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,2,0,6.28); ctx.fill(); ctx.globalAlpha=1;
        }
    }
    class Ripple { constructor(x,y,c) { this.x=x; this.y=y; this.c=c; this.r=20; this.a=1; } update() { this.r+=4; this.a-=0.02; } draw(ctx) { if(this.a<=0)return; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,6.28); ctx.strokeStyle=`rgba(${this.c},${this.a})`; ctx.lineWidth=2; ctx.stroke(); } }
    class Particle {
        constructor(x, y, type, isRoot=false) {
            this.x=x; this.y=y; this.type=type; this.life=1; this.isRoot=isRoot;
            const intensity = window.currentRootIntensity || 0;
            const a=Math.random()*6.28, s=(isRoot?Math.random()*2+1:Math.random()*0.5+0.2)*(1+intensity);
            this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.sz=(Math.random()*2+1)*(1+intensity*0.5);
            if (typeof type === 'object') {
                const roll = Math.random() * type.total;
                if (roll < type.fire) { this.c='255,100,0'; } else if (roll < type.fire + type.ice) { this.c='100,200,255'; } else { this.c='200,200,220'; }
            } else {
                if(type==='fire') { this.c='255,100,0'; } else if(type==='ice') { this.c='100,200,255'; } else { this.c='200,200,220'; }
            }
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.01; }
        draw(ctx) { ctx.fillStyle = `rgba(${this.c},${this.life})`; ctx.beginPath(); ctx.arc(this.x,this.y,this.sz,0,6.28); ctx.fill(); }
    }

    class ParticleSystem {
        constructor() { this.p=[]; this.fp=[]; this.r=[]; this.bg=[]; this.ctx=document.getElementById('effects-canvas').getContext('2d'); for(let i=0;i<800;i++)this.bg.push({x:Math.random()*3000,y:Math.random()*3000,s:Math.random()*1.5,a:Math.random(),c:Math.random()>0.9?'#a5f3fc':(Math.random()>0.8?'#fef08a':'#fff')}); }
        spawnRoot(w) { const intensity = window.currentRootIntensity || 0; if(Math.random()>0.2) return; this.p.push(new Particle(CENTER, CENTER-20, w, true)); }
        spawnRipple(x,y,t) { let c=TREES[t]?TREES[t].color:'255,255,255'; if (t === 'fire') c = '249, 115, 22'; else if (t === 'ice') c = '34, 211, 238'; else if (t === 'phys') c = '226, 232, 240'; this.r.push(new Ripple(x,y,c)); }
        spawnFlow() {
            layoutNodes.forEach(node => {
                if(node.id==='root') return;
                const isHybrid = !['fire','ice','phys','root'].includes(node.data.tree);
                if (isHybrid && !checkRequirements(node.id).met && state.skills[node.id] === 0 && !revealAll) return;
                (node.data.req||[]).forEach(pid => {
                    if(state.skills[pid]>0 && Math.random()<0.02) {
                        const pn = layoutNodes.find(x=>x.id===pid);
                        if (pn) { let c = TREES[node.data.tree].color; this.fp.push(new FlowParticle(pn.x, pn.y, node.x, node.y, c, pid, node.id)); }
                    }
                });
            });
            if(hoveredNodeId) {
                const node = layoutNodes.find(n => n.id === hoveredNodeId);
                const req = checkRequirements(hoveredNodeId);
                if(node && (req.met || state.skills[hoveredNodeId]>0)) {
                    (node.data.req||[]).forEach(pid => {
                        const pn = layoutNodes.find(n => n.id === pid);
                        if(pn && Math.random() < 0.15) this.fp.push(new FlowParticle(pn.x, pn.y, node.x, node.y, '#fff', pid, node.id));
                    });
                    layoutNodes.forEach(child => {
                        if((child.data.req||[]).includes(hoveredNodeId)) {
                            if (state.skills[child.id] === 0 && Math.random() < 0.15) {
                                this.fp.push(new FlowParticle(node.x, node.y, child.x, child.y, 'rgba(255,255,255,0.6)', node.id, child.id));
                            }
                        }
                    });
                }
            }
        }
        render(t) {
            this.ctx.clearRect(0,0,3000,3000);
            this.bg.forEach(s=>{ this.ctx.fillStyle=s.c; this.ctx.globalAlpha=s.a*(0.6+0.4*Math.sin(t*5+s.x)); this.ctx.beginPath(); this.ctx.arc(s.x,s.y,s.s,0,6.28); this.ctx.fill(); });
            this.ctx.globalAlpha=1;
            this.spawnFlow();
            [this.fp, this.p, this.r].forEach(a=>{ for(let i=a.length-1;i>=0;i--){ a[i].update(); if(a[i].l<=0||a[i].life<=0||a[i].a<=0)a.splice(i,1); else a[i].draw(this.ctx); }});
        }
    }

    function getWeights() {
        let c={fire:0,ice:0,phys:0};
        Object.keys(state.skills).forEach(k=>{
            const n=skillsRaw.find(x=>x.id===k);
            if(n&&state.skills[k]>0) {
                const lvl = state.skills[k];
                if(n.tree==='fire') c.fire += lvl;
                else if(n.tree==='ice') c.ice += lvl;
                else if(n.tree==='phys') c.phys += lvl;
                else if(n.tree==='steam') { c.fire+=0.5*lvl; c.ice+=0.5*lvl; }
                else if(n.tree==='forge') { c.fire+=0.5*lvl; c.phys+=0.5*lvl; }
                else if(n.tree==='fracture') { c.ice+=0.5*lvl; c.phys+=0.5*lvl; }
            }
        });
        const total = c.fire + c.ice + c.phys; const maxSpec = Math.max(c.fire, c.ice, c.phys);
        return { ...c, total: total > 0 ? total : 1, maxSpec };
    }

    function updateRootVisuals() {
        const w = getWeights();

        const fireOp = w.fire / w.total;
        const iceOp = w.ice / w.total;
        const physOp = w.phys / w.total;

        const rF = document.querySelector('.root-ring-fire');
        const rI = document.querySelector('.root-ring-ice');
        const rP = document.querySelector('.root-ring-phys');

        if(rF) { rF.style.opacity = 0.1 + fireOp * 0.9; rF.style.strokeWidth = 1.5 + fireOp * 2; rF.style.filter = `drop-shadow(0 0 ${fireOp*10}px #f97316)`; }
        if(rI) { rI.style.opacity = 0.1 + iceOp * 0.9; rI.style.strokeWidth = 1.5 + iceOp * 2; rI.style.filter = `drop-shadow(0 0 ${iceOp*10}px #22d3ee)`; }
        if(rP) { rP.style.opacity = 0.1 + physOp * 0.9; rP.style.strokeWidth = 1.5 + physOp * 2; rP.style.filter = `drop-shadow(0 0 ${physOp*10}px #cbd5e1)`; }

        const book = document.querySelector('.root-book-icon');

        let r, g, b;
        if(w.total <= 1) {
            r=80; g=80; b=90;
        } else {
            r = (w.fire * 249 + w.ice * 34 + w.phys * 226) / w.total;
            g = (w.fire * 115 + w.ice * 211 + w.phys * 232) / w.total;
            b = (w.fire * 22 + w.ice * 238 + w.phys * 240) / w.total;
        }

        const colorStr = `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
        const totalIntensity = Math.min(w.total / 50, 1.0);
        const specIntensity = Math.min(w.maxSpec / 20, 1.0);
        const intensity = Math.max(totalIntensity, specIntensity);

        if(book) {
            book.style.fill = colorStr;
            if(w.total > 1) {
                if (w.fire > 20 && w.ice > 20 && w.phys > 20) {
                    book.style.fill = "#ffffff";
                    book.style.filter = `drop-shadow(0 0 ${20 + 50 * intensity}px white) drop-shadow(0 0 10px white)`;
                } else {
                    book.style.filter = `drop-shadow(0 10px 10px rgba(0,0,0,0.8)) drop-shadow(0 0 ${10 + 30 * intensity}px ${colorStr})`;
                }
            } else {
                book.style.filter = `drop-shadow(0 5px 5px rgba(0,0,0,0.8)) grayscale(100%) brightness(0.5)`;
            }
        }

        const el = document.querySelector('#node-root');
        if(el) {
            const size = 50 + (30 * intensity);
            el.style.width = `${size}px`;
            el.style.height = `${size}px`;
            const rings = el.querySelector('.root-rings');
            if(rings) rings.style.transform = `translate(-50%, -50%) rotateX(65deg) scale(${1 + intensity * 0.5})`;
        }

        window.currentRootIntensity = intensity;
    }

    function applyPreset(type) {
        resetTree();
        revealAll = false;
        if (type === 'all') {
            skillsRaw.forEach(s => { if (s.id !== 'root') state.skills[s.id] = MAX_LEVEL; });
            revealAll = false;
        } else if (type === 'omni') {
            skillsRaw.forEach(s => { if (s.id !== 'root') state.skills[s.id] = MAX_LEVEL; });
            revealAll = true;
        } else {
            skillsRaw.forEach(s => {
                if (s.id === 'root') return;
                if (s.tree === type) state.skills[s.id] = MAX_LEVEL;
            });
        }
        const used = Object.values(state.skills).reduce((a, b) => a + b, 0) - 1;
        state.points = TOTAL_POINTS - used;
        render();
        sys.spawnFlow();
    }

    function checkRequirements(id) {
        const s = skillsRaw.find(x=>x.id===id);
        if(!s.req || !s.req.length) return {met:true};
        const m = s.req.filter(r => state.skills[r]<1);
        return { met: m.length===0, missingText: m.join(',') };
    }
    function handleSkillClick(id) {
        if(id==='root') return;
        const req = checkRequirements(id);
        if(state.skills[id]>=MAX_LEVEL || !req.met || state.points<=0) return;
        state.points--; state.skills[id]++;
        sys.spawnRipple(layoutNodes.find(n=>n.id===id).x, layoutNodes.find(n=>n.id===id).y, skillsRaw.find(x=>x.id===id).tree);
        render();
    }

    function getHybridSVG(icons) {
        let content = '';
        if (icons.length === 2) {
            content = `
                    <g transform="scale(0.6) translate(-4, -4)"><path d="${ICONS[icons[0]]}" /></g>
                    <g transform="scale(0.6) translate(8, 8)"><path d="${ICONS[icons[1]]}" /></g>
                `;
        } else if (icons.length === 3) {
            content = `
                    <g transform="scale(0.5) translate(6, -6)"><path d="${ICONS[icons[0]]}" /></g>
                    <g transform="scale(0.5) translate(-4, 10)"><path d="${ICONS[icons[1]]}" /></g>
                    <g transform="scale(0.5) translate(16, 10)"><path d="${ICONS[icons[2]]}" /></g>
                `;
        }
        return `<svg viewBox="0 0 24 24" class="fill-current skill-node-icon">${content}</svg>`;
    }

    function render() {
        document.getElementById('skill-points-display').innerText = state.points;
        const sl = document.getElementById('skills-layer');
        const cl = document.getElementById('connections-layer');

        if(sl.innerHTML === '') {
            let lH='', nH='';

            const r = layoutNodes.find(n=>n.id==='root');
            nH += `
                <div id="node-root" class="skill-node node-root" style="width:50px; height:50px; left:${r.x-25}px; top:${r.y-25}px;">
                    <div class="root-book-container">
                        <svg viewBox="0 0 24 24" class="root-book-icon"><path d="${ICONS.book_open}"/></svg>
                    </div>
                    <svg class="root-rings" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="25" class="root-ring root-ring-fire ring-fire-anim" stroke="#f97316" />
                        <circle cx="50" cy="50" r="35" class="root-ring root-ring-ice ring-ice-anim" stroke="#22d3ee" />
                        <circle cx="50" cy="50" r="45" class="root-ring root-ring-phys ring-phys-anim" stroke="#cbd5e1" />
                    </svg>
                </div>`;

            layoutNodes.forEach(n => {
                if(n.id!=='root') {
                    (n.data.req||[]).forEach(pid => {
                        const p = layoutNodes.find(x=>x.id===pid);
                        if(p) {
                            const isHybrid = !['fire','ice','phys','root'].includes(n.data.tree);
                            const cls = isHybrid ? 'connection-line line-hybrid' : 'connection-line line-locked';
                            lH += `<path id="line-${pid}-${n.id}" d="M ${p.x} ${p.y} L ${n.x} ${n.y}" class="${cls}" />`;
                        }
                    });

                    const sz = 40;
                    let iconHTML = '';
                    if (TREES[n.data.tree].icons) iconHTML = getHybridSVG(TREES[n.data.tree].icons);
                    else iconHTML = `<svg class="skill-node-icon" viewBox="0 0 24 24"><path d="${ICONS[n.data.icon]||ICONS.spark}"/></svg>`;

                    const ringsHTML = `
                        <svg class="node-progress-rings" viewBox="0 0 100 100">
                            <circle class="ring-outer prog-ring" cx="50" cy="50" r="46" />
                            <circle class="ring-mid prog-ring" cx="50" cy="50" r="36" />
                            <circle class="ring-inner prog-ring" cx="50" cy="50" r="26" />
                        </svg>`;

                    nH += `<div id="node-${n.id}" class="skill-node node-${n.data.tree}" style="width:${sz}px; height:${sz}px; left:${n.x-sz/2}px; top:${n.y-sz/2}px;" onclick="handleSkillClick('${n.id}')" onmouseenter="hoverNode('${n.id}',true)" onmouseleave="hoverNode('${n.id}',false)">
                            ${ringsHTML}
                            ${iconHTML}
                        </div>`;
                }
            });
            cl.innerHTML = lH; sl.innerHTML = nH;
        }

        layoutNodes.forEach(n => {
            if(n.id==='root')return;
            const el=document.getElementById(`node-${n.id}`);
            const lvl=state.skills[n.id];
            const req=checkRequirements(n.id);

            const isHybrid = !['fire','ice','phys','root'].includes(n.data.tree);
            const isVisible = !isHybrid || (isHybrid && (req.met || lvl > 0 || revealAll));

            if (!isVisible) { el.classList.add('node-hidden'); }
            else {
                el.classList.remove('node-hidden');
                if(isHybrid && (req.met || lvl > 0 || revealAll)) {
                    const label = document.getElementById(`label-${n.data.tree}`);
                    if(label) label.classList.remove('label-hidden');
                }
            }

            let lvlClass = 'lvl-0';
            if(lvl === 1) lvlClass = 'lvl-1';
            if(lvl === 2) lvlClass = 'lvl-2';
            if(lvl === 3) lvlClass = 'lvl-3';

            el.className = `skill-node node-${n.data.tree} ${isVisible?'':'node-hidden'} ${lvlClass}`;

            if(lvl>0){el.classList.add('node-active');if(lvl>=MAX_LEVEL)el.classList.add('node-maxed');}
            else if(req.met&&state.points>0)el.classList.add('node-available');
            else el.classList.add('node-locked');

            (n.data.req||[]).forEach(pid => {
                const line = document.getElementById(`line-${pid}-${n.id}`);
                if (line) {
                    if(!isVisible) line.classList.add('line-hidden'); else line.classList.remove('line-hidden');
                    const pLvl = state.skills[pid];
                    const color = TREES[n.data.tree].color;
                    line.setAttribute('class', isHybrid ? 'connection-line line-hybrid' : 'connection-line');
                    line.style.stroke = '';
                    if (!isVisible) line.classList.add('line-hidden');
                    else if(lvl>0) { line.classList.add('line-active'); line.style.stroke = color; }
                    else if(pLvl>0 && !isHybrid) line.classList.add('line-available');
                    else if(!isHybrid) line.classList.add('line-locked');
                }
            });
        });
        updateRootVisuals();
    }

    function hoverNode(id, h) {
        hoveredNodeId = h ? id : null;
        const el=document.getElementById(`node-${id}`);
        if (!el || el.classList.contains('node-hidden')) return;

        const req = checkRequirements(id);
        const isAvailable = req.met || state.skills[id] > 0;

        if(h){
            el.classList.add('is-hovered');
            showTooltip(layoutNodes.find(x=>x.id===id));

            if (isAvailable) {
                focusContext.active = true;
                focusContext.valid.clear();
                const ancestors = getAncestors(id);
                const directUnlitChildren = getDirectUnlitChildren(id);

                ancestors.forEach(a => focusContext.valid.add(a));
                focusContext.valid.add(id);
                directUnlitChildren.forEach(c => focusContext.valid.add(c));

                layoutNodes.forEach(n => {
                    if (n.id !== id && !ancestors.has(n.id) && !directUnlitChildren.has(n.id)) {
                        const nEl = document.getElementById(`node-${n.id}`);
                        if(nEl && !nEl.classList.contains('node-hidden')) nEl.classList.add('is-dimmed');
                    }
                });

                document.querySelectorAll('.connection-line').forEach(line => {
                    if(line.classList.contains('line-hidden')) return;
                    const parts = line.id.split('-');
                    const pId = parts[1]; const cId = parts[2];
                    const pRel = ancestors.has(pId); const cRel = ancestors.has(cId);
                    const pIsHover = pId === id; const cIsChild = directUnlitChildren.has(cId);
                    const relevant = (pRel && (cRel || cId === id)) || (pIsHover && cIsChild);

                    if (!relevant) line.classList.add('is-dimmed');
                    else focusContext.valid.add(`${pId}-${cId}`);
                });
            }
        } else {
            el.classList.remove('is-hovered');
            document.getElementById('tooltip').style.display='none';
            document.querySelectorAll('.is-dimmed').forEach(e => e.classList.remove('is-dimmed'));
            focusContext.active = false;
            focusContext.valid.clear();
        }
    }

    function getAncestors(nodeId, visited = new Set()) {
        if (visited.has(nodeId)) return visited;
        visited.add(nodeId);
        const node = skillsRaw.find(n => n.id === nodeId);
        if (!node) return visited;
        (node.req || []).forEach(pid => getAncestors(pid, visited));
        return visited;
    }

    function getDirectUnlitChildren(nodeId) {
        const childrenIds = new Set();
        skillsRaw.forEach(n => {
            if ((n.req || []).includes(nodeId) && state.skills[n.id] === 0) { childrenIds.add(n.id); }
        });
        return childrenIds;
    }

    function showTooltip(n) {
        const tt=document.getElementById('tooltip'); const lvl=state.skills[n.id];
        tt.querySelector('#tt-name').innerText=n.data.name; tt.querySelector('#tt-desc').innerText=n.data.desc; tt.querySelector('#tt-rank').innerText=`${lvl}/${MAX_LEVEL}`;
        tt.style.display='block'; const el=document.getElementById(`node-${n.id}`); const r=el.getBoundingClientRect(); tt.style.left=(r.right+10)+'px'; tt.style.top=r.top+'px';
    }
    function autoUnlock() { Object.keys(state.skills).forEach(k=>{if(Math.random()>0.6&&k!=='root')state.skills[k]=1;}); render(); }
    function resetTree() { state.points=TOTAL_POINTS; for(let k in state.skills)if(k!=='root')state.skills[k]=0; render(); }

    window.onload = () => {
        const vp = document.getElementById('viewport');

        sys = new ParticleSystem();
        precomputeLayout();

        let d=false, sx, sy, sl, st;
        let scale = 1;
        let pointX = (window.innerWidth / 2) - (CENTER * scale);
        let pointY = (window.innerHeight / 2) - (CENTER * scale);
        let startX = 0;
        let startY = 0;
        let panning = false;

        const content = document.getElementById('canvas-content');
        function setTransform() {
            content.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        }
        setTransform();

        vp.onmousedown = (e) => {
            panning = true;
            startX = e.clientX - pointX;
            startY = e.clientY - pointY;
            vp.style.cursor = 'grabbing';
        };
        window.onmouseup = () => {
            panning = false;
            vp.style.cursor = 'grab';
        };
        window.onmousemove = (e) => {
            if (!panning) return;
            e.preventDefault();
            pointX = e.clientX - startX;
            pointY = e.clientY - startY;
            setTransform();
        };
        vp.addEventListener('wheel', (e) => {
            e.preventDefault();
            const xs = (e.clientX - pointX) / scale;
            const ys = (e.clientY - pointY) / scale;
            const delta = -Math.sign(e.deltaY) * 0.1;
            const nextScale = Math.min(Math.max(0.2, scale + delta), 3.0);
            pointX = e.clientX - xs * nextScale;
            pointY = e.clientY - ys * nextScale;
            scale = nextScale;
            setTransform();
        }, { passive: false });

        function loop(t) {
            const weights = getWeights();
            sys.spawnRoot(weights);
            sys.render(t/1000); requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    };
</script>
</body>
</html>