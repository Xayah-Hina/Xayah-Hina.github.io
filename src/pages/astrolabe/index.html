<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>星图天赋树 - 聚焦流光版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Noto+Serif+SC:wght@300;400;700&display=swap');

        body {
            font-family: 'Noto Serif SC', serif;
            background-color: #020204;
            color: #e0e0e0;
            overflow: hidden;
            user-select: none;
        }

        .magic-font { font-family: 'Cinzel', serif; }

        /* --- 背景 --- */
        #space-background {
            position: absolute;
            width: 100%; height: 100%;
            left: 0; top: 0;
            background-color: #020204;
            background-image:
                    radial-gradient(circle at 50% 50%, rgba(20, 20, 35, 0.6) 0%, transparent 80%),
                    radial-gradient(circle at 50% 0%, rgba(249, 115, 22, 0.03) 0%, transparent 40%),
                    radial-gradient(circle at 80% 20%, rgba(34, 211, 238, 0.03) 0%, transparent 40%),
                    radial-gradient(circle at 50% 80%, rgba(203, 213, 225, 0.03) 0%, transparent 40%);
            z-index: 0;
            pointer-events: none;
        }

        #magic-hexagram {
            position: absolute; top: 50%; left: 50%; width: 1400px; height: 1400px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 1;
            opacity: 0.03; fill: none; stroke: url(#hex-gradient); stroke-width: 1;
            animation: rotate-hexagram 300s linear infinite;
        }
        @keyframes rotate-hexagram { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        /* --- 节点样式 --- */
        .skill-node {
            position: absolute;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            border-radius: 50%; z-index: 30;
            transition: transform 0.3s, border-color 0.3s, background-color 0.3s, box-shadow 0.3s, opacity 0.3s, filter 0.3s;
            will-change: transform, left, top;
            background: #0f0f15;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.15);
        }

        .skill-node svg {
            width: 55%; height: 55%; transition: all 0.3s; z-index: 2;
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.8));
        }

        /* 状态 */
        .node-locked { border-color: rgba(255,255,255,0.05); background: rgba(10,10,15,0.95); opacity: 0.6; }
        .node-locked svg { fill: rgba(255,255,255,0.1); }

        .node-available {
            cursor: pointer;
            border-color: rgba(255,255,255,0.5);
            animation: breathe-node 3s infinite alternate ease-in-out;
        }

        .node-active {
            cursor: pointer;
            border-color: #fff;
            background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, rgba(0,0,0,0) 70%);
            animation: breathe-node 4s infinite alternate ease-in-out;
        }

        .node-maxed {
            border-color: #fff !important;
            box-shadow: 0 0 20px currentColor, inset 0 0 15px rgba(255,255,255,0.3);
            animation: breathe-node-heavy 2s infinite alternate ease-in-out;
        }
        .node-maxed svg { fill: #fff !important; filter: drop-shadow(0 0 8px rgba(255,255,255,0.9)); }

        /* 悬浮高亮 */
        .skill-node.is-hovered {
            z-index: 50;
            transform: scale(1.2) !important;
            box-shadow: 0 0 30px currentColor !important;
        }

        /* 新增：被淡化的节点 (Dimmed) */
        .skill-node.is-dimmed {
            opacity: 0.1 !important;
            filter: grayscale(100%) blur(1px) !important;
            animation: none !important;
            z-index: 10;
        }

        /* 呼吸动画 */
        @keyframes breathe-node {
            0% { transform: scale(1); box-shadow: 0 0 5px currentColor; }
            100% { transform: scale(1.05); box-shadow: 0 0 15px currentColor; }
        }
        @keyframes breathe-node-heavy {
            0% { transform: scale(1); box-shadow: 0 0 15px currentColor; }
            100% { transform: scale(1.1); box-shadow: 0 0 30px currentColor; }
        }

        /* --- 属性颜色 --- */
        .node-fire { color: #f97316; } .node-fire svg { fill: #c2410c; } .node-fire.node-active svg { fill: #fb923c; }
        .node-ice { color: #22d3ee; } .node-ice svg { fill: #0e7490; } .node-ice.node-active svg { fill: #67e8f9; }
        .node-phys { color: #cbd5e1; } .node-phys svg { fill: #475569; } .node-phys.node-active svg { fill: #e2e8f0; }

        /* 混合系颜色 */
        .node-steam { color: #d8b4fe; } .node-steam svg { fill: #9333ea; } .node-steam.node-active svg { fill: #e9d5ff; }
        .node-fracture { color: #2dd4bf; } .node-fracture svg { fill: #0d9488; } .node-fracture.node-active svg { fill: #99f6e4; }
        .node-forge { color: #fbbf24; } .node-forge svg { fill: #b45309; } .node-forge.node-active svg { fill: #fde68a; }
        .node-void { color: #ffffff; } .node-void svg { fill: #555; } .node-void.node-active svg { fill: #fff; }

        /* Root Node */
        .node-root {
            border-width: 2px;
            z-index: 60;
            transition: border-color 1s, box-shadow 1s, background-color 1s, width 0.5s, height 0.5s;
        }
        .node-root svg {
            transition: fill 1s, filter 1s;
            width: 65% !important; height: 65% !important;
        }

        /* --- 连接线 --- */
        .connection-line { fill: none; stroke-width: 1.5; stroke-linecap: round; transition: all 0.4s; }
        .line-locked { stroke: rgba(255,255,255,0.08); stroke-dasharray: 4, 8; opacity: 0.3; }
        .line-available { stroke: rgba(255,255,255,0.3); stroke-dasharray: 3, 5; }
        .line-active { stroke-dasharray: none !important; stroke-width: 2; opacity: 0.8; filter: drop-shadow(0 0 3px currentColor); animation: breathe-line 3s infinite alternate ease-in-out; }

        /* 新增：被淡化的连线 */
        .connection-line.is-dimmed {
            opacity: 0.05 !important;
            stroke-width: 1 !important;
            animation: none !important;
        }

        /* 星际长线 */
        .line-hybrid { opacity: 0.4; stroke-width: 1; stroke-dasharray: 8, 4; animation: flow-dash 20s linear infinite !important; }
        .line-hybrid.line-active { opacity: 0.9; stroke-width: 2; stroke-dasharray: 4, 4; filter: drop-shadow(0 0 5px currentColor); animation: flow-dash 2s linear infinite !important; }

        .connection-line.is-hovered { stroke: rgba(255, 255, 255, 0.8) !important; stroke-dasharray: 4, 4 !important; stroke-width: 2.5 !important; opacity: 1 !important; filter: drop-shadow(0 0 5px white); animation: dash-move 1s linear infinite !important; z-index: 40; }
        .connection-line.line-active.is-hovered { stroke-dasharray: none !important; animation: none !important; filter: drop-shadow(0 0 8px currentColor); }

        @keyframes breathe-line { 0% { opacity: 0.6; stroke-width: 2; } 100% { opacity: 1; stroke-width: 3; } }
        @keyframes dash-move { to { stroke-dashoffset: -16; } }
        @keyframes flow-dash { to { stroke-dashoffset: -100; } }

        .line-fire { color: #f97316; stroke: #f97316; }
        .line-ice { color: #22d3ee; stroke: #22d3ee; }
        .line-phys { color: #94a3b8; stroke: #94a3b8; }
        .line-steam { color: #d8b4fe; stroke: #d8b4fe; }
        .line-fracture { color: #2dd4bf; stroke: #2dd4bf; }
        .line-forge { color: #fbbf24; stroke: #fbbf24; }
        .line-void { color: #fff; stroke: #fff; }

        #effects-canvas { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 25; }
        #tooltip { pointer-events: none; z-index: 100; transition: opacity 0.2s; }

        .level-badge {
            position: absolute; bottom: -15px; font-size: 9px;
            padding: 0 3px; border-radius: 2px;
            background: #000; border: 1px solid rgba(255,255,255,0.15);
            color: #888; font-family: monospace; pointer-events: none;
        }

        #loading-mask {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #020204; z-index: 9999;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; transition: opacity 0.5s;
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

<div id="loading-mask">
    <div class="text-amber-500 magic-font text-2xl animate-pulse mb-4">Simulating Deep Space...</div>
    <div class="w-48 h-1 bg-gray-800 rounded overflow-hidden">
        <div id="loading-bar" class="h-full bg-amber-500 w-0 transition-all duration-75"></div>
    </div>
</div>

<header class="fixed top-0 left-0 w-full z-50 px-8 py-6 flex justify-between items-start pointer-events-none">
    <div class="pointer-events-auto">
        <h1 class="text-4xl magic-font text-white font-bold tracking-[0.1em] drop-shadow-[0_0_15px_rgba(255,255,255,0.5)]">
            ASTROLABE
        </h1>
        <p class="text-xs text-blue-200/40 uppercase tracking-[0.4em] mt-1 pl-1">Interstellar Skill Map</p>
    </div>
    <div class="flex flex-col items-end pointer-events-auto gap-3">
        <div class="bg-black/40 backdrop-blur-md border border-white/10 rounded-lg px-5 py-2 flex items-center gap-3 shadow-lg">
            <span class="text-white/50 text-[10px] uppercase tracking-widest">Star Dust</span>
            <span id="skill-points-display" class="text-2xl font-bold text-amber-400 magic-font drop-shadow-[0_0_10px_rgba(251,191,36,0.5)]">0</span>
        </div>
        <div class="flex gap-2">
            <button onclick="autoUnlock()" class="text-[10px] text-blue-400/50 hover:text-blue-400 uppercase tracking-widest transition-colors bg-black/20 px-2 py-1 rounded border border-white/5">
                [ Auto Demo ]
            </button>
            <button onclick="resetTree()" class="text-[10px] text-red-400/50 hover:text-red-400 uppercase tracking-widest transition-colors bg-black/20 px-2 py-1 rounded border border-white/5">
                [ Reset ]
            </button>
        </div>
    </div>
</header>

<div class="flex-1 relative overflow-hidden bg-black cursor-move" id="viewport">
    <div id="canvas-content" class="absolute top-0 left-0 w-[3000px] h-[3000px] origin-center will-change-transform">
        <div id="space-background"></div>

        <svg id="magic-hexagram" viewBox="0 0 100 100">
            <defs>
                <linearGradient id="hex-gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" stop-color="#4c1d95" stop-opacity="0.5" />
                    <stop offset="100%" stop-color="#db2777" stop-opacity="0.5" />
                </linearGradient>
            </defs>
            <polygon points="50 5, 90 25, 90 75, 50 95, 10 75, 10 25" fill="none" stroke-width="0.5" />
            <circle cx="50" cy="50" r="35" fill="none" stroke-width="0.2" stroke="rgba(255,255,255,0.2)" />
        </svg>

        <!-- 主系标签 -->
        <div class="constellation-label" style="left: 50%; top: 20%; color: rgba(249, 115, 22, 0.08);">INFERNO</div>
        <div class="constellation-label" style="left: 80%; top: 75%; color: rgba(34, 211, 238, 0.08);">GLACIAL</div>
        <div class="constellation-label" style="left: 20%; top: 75%; color: rgba(203, 213, 225, 0.08);">TITAN</div>

        <!-- 混合系标签 -->
        <div class="constellation-label" style="left: 80%; top: 35%; font-size: 2rem; color: rgba(216, 180, 254, 0.1);">STEAM</div>
        <div class="constellation-label" style="left: 50%; top: 85%; font-size: 2rem; color: rgba(94, 234, 212, 0.1);">FRACTURE</div>
        <div class="constellation-label" style="left: 20%; top: 35%; font-size: 2rem; color: rgba(253, 230, 138, 0.1);">FORGE</div>

        <svg id="connections-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 overflow-visible"></svg>
        <canvas id="effects-canvas" width="3000" height="3000"></canvas>
        <div id="skills-layer" class="absolute top-0 left-0 w-full h-full z-30"></div>
    </div>
</div>

<div id="tooltip" class="fixed hidden w-80 bg-[#0a0a0e]/90 backdrop-blur-xl border border-white/15 p-5 shadow-[0_0_50px_rgba(0,0,0,0.8)] text-left z-[100] rounded-lg ring-1 ring-white/10">
    <div class="flex justify-between items-start mb-2">
        <h3 id="tt-name" class="text-lg font-bold text-white magic-font tracking-wide uppercase drop-shadow-md">Name</h3>
        <div id="tt-icon" class="w-6 h-6 opacity-90"></div>
    </div>
    <div class="flex items-center gap-3 mb-3">
        <span id="tt-type" class="text-[9px] font-bold uppercase tracking-widest text-black bg-white/90 px-2 py-0.5 rounded-sm shadow-sm">Passive</span>
        <div class="h-px flex-1 bg-gradient-to-r from-white/20 to-transparent"></div>
        <span id="tt-rank" class="text-xs text-amber-400 font-mono text-shadow">0/3</span>
    </div>
    <p id="tt-desc" class="text-xs text-gray-400 mb-4 leading-relaxed font-light opacity-90">Description...</p>
    <div class="space-y-1 border-t border-white/10 pt-2">
        <div id="tt-next" class="text-[10px] text-emerald-400 font-mono"></div>
        <div id="tt-req" class="text-[10px] text-red-400 font-mono"></div>
    </div>
</div>

<script>
    const CANVAS_SIZE = 3000;
    const CENTER = CANVAS_SIZE / 2;
    const MAX_LEVEL = 3;

    const TREES = {
        root: { color: '#fbbf24', angle: 0 },
        fire: { color: '#f97316', angle: -90 },
        ice:  { color: '#22d3ee', angle: 30 },
        phys: { color: '#e2e8f0', angle: 150 },
        steam: { color: '#d8b4fe', angle: -30 },
        fracture: { color: '#2dd4bf', angle: 90 },
        forge: { color: '#fbbf24', angle: 210 },
        void: { color: '#ffffff', angle: 0 }
    };

    const BASE_SIZE = 40;

    const ICONS = {
        root: 'M19 3h-4.18C14.4 1.84 13.3 1 12 1s-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h5c1.1 0 2-.9 2-2V7h2v10c0 1.1.9 2 2 2h5c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 2h2v2h-2V5zm0 12h-2v-2h2v2zm0-4h-2V9h2v4zm-5 4l-2-2 1.41-1.41L10 16.17l4.59-4.59L16 13l-6 6z M18 19h-5v-2h5v2zm0-4h-5v-2h5v2zm0-4h-5V9h5v2z',
        fire_basic: 'M12 23c5.52 0 10-4.48 10-10 0-4-3.25-7.41-7.1-8.93-.56-.22-.59-.98-.05-1.24 2.54-1.22 4.15-3.98 4.15-6.83 0-.55-.45-1-1-1-.34 0-.66.18-.84.47-1.5 2.46-4.31 4.24-7.5 4.5-3.18.26-6.04-1.5-7.57-4.02-.17-.29-.48-.45-.81-.45-.55 0-1 .45-1 1 0 2.85 1.61 5.61 4.15 6.83.54.26.51 1.02-.05 1.24C3.25 5.59 0 9 0 13c0 5.52 4.48 10 10 10s10-4.48 10-10c0-1.85-.51-3.58-1.4-5.06-.47-.78-1.55-.78-2.02 0C15.69 9.42 15.18 11.15 15.18 13c0 1.76-1.42 3.18-3.18 3.18-1.76 0-3.18-1.42-3.18-3.18 0-1.85.51-3.58 1.4-5.06.47-.78-.61-1.78-1.4-1.29C5.33 8.67 3.18 10.67 3.18 13c0 4.86 3.94 8.82 8.82 8.82 4.88 0 8.82-3.96 8.82-8.82 0-.68-.09-1.34-.25-1.98-.24-.96 1.05-1.62 1.68-.84C22.77 11.27 23.18 12.11 23.18 13c0 6.08-4.92 11-11 11z',
        fire_ball: 'M19.48,13.03C19.34,12.85 19.13,12.75 18.9,12.76C18.68,12.78 18.48,12.9 18.37,13.1C17.88,13.94 16.98,14.5 15.95,14.5C15.5,14.5 15.09,14.38 14.71,14.18C15.69,13.56 16.34,12.47 16.34,11.22C16.34,9.41 14.97,7.91 13.21,7.73C13.18,7.73 13.15,7.73 13.12,7.73C13.09,5.87 13.56,4.21 14.24,2.8C14.32,2.63 14.31,2.43 14.21,2.27C14.11,2.11 13.94,2 13.75,2C11.35,2 7.73,5.16 7.73,9.84C7.73,10 7.74,10.15 7.76,10.3C6.06,11.34 5,13.32 5,15.5C5,19.09 7.91,22 11.5,22C14.84,22 17.59,19.49 17.95,16.25C18.67,15.42 19.24,14.33 19.48,13.03M11.5,20.5C8.74,20.5 6.5,18.26 6.5,15.5C6.5,13.71 7.44,12.15 8.87,11.23L9.5,10.82L9.23,10.11C9.22,10.08 9.22,10.05 9.22,10.03C9.24,10.03 9.25,10.04 9.27,10.04C9.29,10.05 9.32,10.06 9.34,10.07C9.54,10.15 9.77,10.19 10,10.19C10.28,10.19 10.54,10.13 10.79,10.03L11.46,9.75L11.55,10.47C11.85,12.83 13.86,14.65 16.28,14.65C16.41,14.65 16.54,14.64 16.66,14.63C16.45,17.93 14.23,20.5 11.5,20.5Z',
        fire_spark: 'M11,21H13V19H11V21M15.14,18.5L16.85,20.2L18.27,18.79L16.56,17.09L15.14,18.5M8.86,18.5L7.44,17.09L5.73,18.79L7.15,20.2L8.86,18.5M12,17C14.21,17 16,15.21 16,13C16,8 12,2 12,2C12,2 8,8 8,13C8,15.21 9.79,17 12,17M12,7.41C13,10.08 14,12.06 14,13C14,14.1 13.1,15 12,15C10.9,15 10,14.1 10,13C10,12.06 11,10.08 12,7.41Z',
        ice_flake: 'M21,11L14.17,11L16.59,8.59L15.17,7.17L12,10.34L8.83,7.17L7.41,8.59L9.83,11L3,11V13L9.83,13L7.41,15.41L8.83,16.83L12,13.66L15.17,16.83L16.59,15.41L14.17,13L21,13V11M12,2L9.17,4.83L10.59,6.24L12,4.83L13.41,6.24L14.83,4.83L12,2M4.83,9.17L2,12L4.83,14.83L6.24,13.41L4.83,12L6.24,10.59L4.83,9.17M19.17,9.17L17.76,10.59L19.17,12L17.76,13.41L19.17,14.83L22,12L19.17,9.17M12,22L14.83,19.17L13.41,17.76L12,19.17L10.59,17.76L9.17,19.17L12,22Z',
        ice_spike: 'M12,2L15,8L21,9L16,14L18,20L12,17L6,20L8,14L3,9L9,8L12,2M12,5.8L10.5,8.8L7.5,9.3L10,11.8L9.2,14.8L12,13.3L14.8,14.8L14,11.8L16.5,9.3L13.5,8.8L12,5.8Z',
        ice_crystal: 'M22,12L17,12L19,10L16,7L12,11L8,7L5,10L7,12L2,12L7,17L5,19L8,22L12,18L16,22L19,19L17,17L22,12M12,15.5L9.5,13L12,10.5L14.5,13L12,15.5Z',
        phys_shield: 'M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4z',
        phys_sword: 'M14.5 12.59l.9 3.88-3.92.55 1.56-6.27c.22-.88.18-1.82-.13-2.67C11.8 4.48 8.92 3 5.09 3c-.56 0-1.05.41-1.08.97L4 6l2.05.23c1.15.13 1.9.5 2.27.99.19.25.32.54.39.84l.28.96L7.1 16.1l.89.12L9.86 9.4l1.23 4.94-.57 2.54 4.04-.56 1.07-4.3 1.58.73c1.33.62 1.79 2.22 1.06 3.5l-2.24 3.92c-.48.85-.25 1.93.52 2.5.77.57 1.86.5 2.52-.16l3.12-3.12c.75-.75.96-1.89.51-2.85l-2.71-5.81-5.89-2.73z',
        phys_axe: 'M12 2l-5.5 9h11z M12 22v-8',
        hybrid_dual: 'M6 2l2 6-4 4 6 2-2 6 4-4 6 2-2-6 4-4-6-2 2-6-4 4z',
        hybrid_cloud: 'M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z',
        hybrid_star: 'M12 0l3 9 9 3-9 3-3 9-3-9-9-3 9-3z'
    };

    /* --- 技能数据 --- */
    const skillsRaw = [{ id: 'root', tree: 'root', name: 'Grimoire of Origins', icon: 'root', type: 'Core', tier: 0, desc: 'The source of all magical knowledge.' }];
    const mkId = (t, i) => `${t}${i}`;

    // 1. 基础树生成
    function generateTree(treeType, prefixes, iconList, count) {
        let nodes = [];
        const coreId = mkId(treeType.charAt(0), 1);
        nodes.push({ id: coreId, tree: treeType, name: `${prefixes[0]} Core`, icon: iconList[0], tier: 1, req: ['root'], desc: `Tier 1 ${treeType} skill.` });
        let layerPrev = [coreId]; let currentId = 2; const maxTiers = 6;
        for(let t=2; t<=maxTiers; t++) {
            let layerCurrent = []; if(nodes.length >= count) break;
            layerPrev.forEach(parentId => {
                const numChildren = (Math.random() > 0.5 && nodes.length < count - 2) ? 2 : 1;
                for(let c=0; c<numChildren; c++) {
                    if(nodes.length >= count) break;
                    const id = mkId(treeType.charAt(0), currentId++);
                    nodes.push({ id: id, tree: treeType, name: `${prefixes[Math.floor(Math.random()*prefixes.length)]} ${t}-${c}`, icon: iconList[Math.floor(Math.random()*iconList.length)], tier: t, req: [parentId], desc: 'Skill description.' });
                    layerCurrent.push(id);
                }
            });
            layerPrev = layerCurrent;
        }
        return nodes;
    }

    const fireNodes = generateTree('fire', ['Flame', 'Pyro', 'Ash', 'Magma'], ['fire_basic', 'fire_ball', 'fire_spark'], 32);
    const iceNodes = generateTree('ice', ['Frost', 'Cold', 'Ice', 'Snow'], ['ice_flake', 'ice_spike', 'ice_crystal'], 32);
    const physNodes = generateTree('phys', ['Iron', 'Steel', 'War', 'Blood'], ['phys_sword', 'phys_shield', 'phys_axe'], 32);
    skillsRaw.push(...fireNodes, ...iceNodes, ...physNodes);

    // 2. 混合系生成 (Fix ID conflict)
    function generateHybrids(type, parentTree1, parentTree2, icon, namePrefix) {
        const t1Nodes = skillsRaw.filter(n => n.tree === parentTree1 && n.tier >= 3);
        const t2Nodes = skillsRaw.filter(n => n.tree === parentTree2 && n.tier >= 3);
        if (t1Nodes.length === 0 || t2Nodes.length === 0) return;
        let hybrids = []; const count = 8;

        // Unique prefix
        let prefix = type.charAt(0);
        if(type === 'fracture') prefix = 'fr';
        if(type === 'forge') prefix = 'fo';
        if(type === 'steam') prefix = 'st';

        for(let i=0; i<count; i++) {
            const p1 = t1Nodes[Math.floor(Math.random() * t1Nodes.length)];
            const p2 = t2Nodes[Math.floor(Math.random() * t2Nodes.length)];
            const id = mkId(prefix, i + 1);
            let reqs = [p1.id, p2.id]; if (i > 0 && Math.random() > 0.3) reqs = [hybrids[i-1].id, p1.id];
            hybrids.push({ id: id, tree: type, name: `${namePrefix} ${i+1}`, icon: icon, tier: 99, req: reqs, desc: `Hybrid ${type} skill.` });
        }
        skillsRaw.push(...hybrids);
    }
    generateHybrids('steam', 'fire', 'ice', 'hybrid_cloud', 'Mist');
    generateHybrids('fracture', 'ice', 'phys', 'hybrid_dual', 'Shatter');
    generateHybrids('forge', 'phys', 'fire', 'hybrid_star', 'Molten');

    // Void skill
    const lastSteam = skillsRaw.filter(n=>n.tree==='steam').pop();
    const lastFracture = skillsRaw.filter(n=>n.tree==='fracture').pop();
    const lastForge = skillsRaw.filter(n=>n.tree==='forge').pop();
    const voidReqs = [];
    if(lastSteam) voidReqs.push(lastSteam.id);
    if(lastFracture) voidReqs.push(lastFracture.id);
    if(lastForge) voidReqs.push(lastForge.id);
    if(voidReqs.length > 0) skillsRaw.push({ id: 'void1', tree: 'void', name: 'Void Singularity', icon: 'root', tier: 100, req: voidReqs, desc: 'Ultimate.' });

    let state = { points: 100, skills: { 'root': 1 } };
    skillsRaw.filter(s => s.id !== 'root').forEach(s => state.skills[s.id] = 0);
    let hoveredNodeId = null;
    window.currentRootIntensity = 0;

    /* --- 物理引擎 --- */
    class Simulation {
        constructor(nodes) {
            this.nodes = nodes.map(n => ({ id: n.id, data: n, x: CENTER + (Math.random()-0.5)*200, y: CENTER + (Math.random()-0.5)*200, vx: 0, vy: 0 }));
            this.links = [];
            this.nodes.forEach(node => {
                if(node.data.req) node.data.req.forEach(pid => {
                    const parent = this.nodes.find(n => n.id === pid);
                    if(parent) this.links.push({ source: parent, target: node });
                });
            });
        }
        tick() {
            const k_repulse = 7500, k_spring = 0.06, k_center = 0.008, len_spring = 90;
            this.nodes.forEach(n => {
                if(n.id === 'root') { n.x = CENTER; n.y = CENTER; n.vx=0; n.vy=0; return; }
                n.vx += (CENTER - n.x) * k_center; n.vy += (CENTER - n.y) * k_center;
                if (['fire', 'ice', 'phys'].includes(n.data.tree)) {
                    const conf = TREES[n.data.tree];
                    const angleRad = conf.angle * Math.PI / 180;
                    const targetDist = n.data.tier * 150;
                    n.vx += (CENTER + Math.cos(angleRad) * targetDist - n.x) * 0.015;
                    n.vy += (CENTER + Math.sin(angleRad) * targetDist - n.y) * 0.015;
                }
            });
            for(let i=0; i<this.nodes.length; i++) {
                for(let j=i+1; j<this.nodes.length; j++) {
                    const a = this.nodes[i], b = this.nodes[j];
                    const dx = a.x - b.x, dy = a.y - b.y, d2 = dx*dx + dy*dy;
                    if(d2 > 0 && d2 < 600000) {
                        const f = k_repulse / d2, fx = (dx/Math.sqrt(d2)) * f, fy = (dy/Math.sqrt(d2)) * f;
                        if (!['fire','ice','phys'].includes(a.data.tree) || !['fire','ice','phys'].includes(b.data.tree)) {
                            if(a.id !== 'root') { a.vx += fx * 0.2; a.vy += fy * 0.2; }
                            if(b.id !== 'root') { b.vx -= fx * 0.2; b.vy -= fy * 0.2; }
                        } else {
                            if(a.id !== 'root') { a.vx += fx; a.vy += fy; }
                            if(b.id !== 'root') { b.vx -= fx; b.vy -= fy; }
                        }
                    }
                }
            }
            this.links.forEach(l => {
                const dx = l.target.x - l.source.x, dy = l.target.y - l.source.y, d = Math.sqrt(dx*dx + dy*dy);
                if(d > 0) {
                    let springFactor = k_spring, len = len_spring;
                    const isHybridSource = !['fire','ice','phys','root'].includes(l.source.data.tree);
                    const isHybridTarget = !['fire','ice','phys','root'].includes(l.target.data.tree);
                    if (isHybridSource || isHybridTarget) { len = 250; springFactor = 0.01; }
                    const f = (d - len) * springFactor, fx = (dx/d) * f, fy = (dy/d) * f;
                    if(l.source.id !== 'root') { l.source.vx += fx; l.source.vy += fy; }
                    if(l.target.id !== 'root') { l.target.vx -= fx; l.target.vy -= fy; }
                }
            });
            this.nodes.forEach(n => {
                if(!['fire','ice','phys','root'].includes(n.data.tree)) {
                    const parents = this.links.filter(l => l.target.id === n.id).map(l => l.source);
                    if(parents.length > 0) {
                        let cx = 0, cy = 0; parents.forEach(p => { cx += p.x; cy += p.y; }); cx /= parents.length; cy /= parents.length;
                        n.vx += (cx - n.x) * 0.02; n.vy += (cy - n.y) * 0.02;
                    }
                }
                if(n.id !== 'root') { n.x += n.vx; n.y += n.vy; n.vx *= 0.5; n.vy *= 0.5; }
            });
        }
    }

    const sim = new Simulation(skillsRaw);
    let layoutNodes = [];
    function precomputeLayout() {
        for(let i=0; i<1000; i++) sim.tick();
        layoutNodes = sim.nodes;
        setTimeout(() => {
            document.getElementById('loading-mask').style.opacity = 0;
            setTimeout(() => document.getElementById('loading-mask').style.display = 'none', 500);
            render();
        }, 200);
    }

    /* --- Helper Functions for Highlight Path --- */
    // 1. Get all ancestors (parents of parents...)
    function getAncestors(nodeId, visited = new Set()) {
        if (visited.has(nodeId)) return visited;
        visited.add(nodeId);
        const node = skillsRaw.find(n => n.id === nodeId);
        if (!node) return visited;

        (node.req || []).forEach(pid => getAncestors(pid, visited));
        return visited;
    }

    // 2. Get direct unlit children (forward connection)
    function getDirectUnlitChildren(nodeId) {
        const childrenIds = new Set();
        // Find all nodes that have this node as requirement
        skillsRaw.forEach(n => {
            if ((n.req || []).includes(nodeId)) {
                // Only add if NOT fully lit (level 0).
                // User prompt: "directly connected unlit nodes"
                // Usually this means Available (lvl 0) or Locked (lvl 0).
                // If user means "potential future steps", then lvl 0 nodes are targets.
                if (state.skills[n.id] === 0) {
                    childrenIds.add(n.id);
                }
            }
        });
        return childrenIds;
    }

    /* --- 粒子系统 --- */
    class FlowParticle {
        constructor(sx, sy, tx, ty, color) { this.x=sx; this.y=sy; this.sx=sx; this.sy=sy; this.tx=tx; this.ty=ty; this.color=color; this.p=0; this.life=1; this.sp=0.01+Math.random()*0.005; }
        update() { this.p+=this.sp; this.x=this.sx+(this.tx-this.sx)*this.p; this.y=this.sy+(this.ty-this.sy)*this.p; if(this.p>=1)this.life=0; }
        draw(ctx) { ctx.fillStyle=this.color; ctx.globalAlpha=0.9; ctx.beginPath(); ctx.arc(this.x,this.y,2,0,6.28); ctx.fill(); ctx.globalAlpha=1; }
    }
    class Ripple { constructor(x,y,c) { this.x=x; this.y=y; this.c=c; this.r=20; this.a=1; } update() { this.r+=4; this.a-=0.02; } draw(ctx) { if(this.a<=0)return; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,6.28); ctx.strokeStyle=`rgba(${this.c},${this.a})`; ctx.lineWidth=2; ctx.stroke(); } }
    class Particle {
        constructor(x, y, type, isRoot=false) {
            this.x=x; this.y=y; this.type=type; this.life=1; this.isRoot=isRoot;
            const intensity = window.currentRootIntensity || 0;
            const a=Math.random()*6.28;
            const s = (isRoot ? (Math.random()*2+1) : (Math.random()*0.5+0.2)) * (1 + intensity);
            this.vx=Math.cos(a)*s; this.vy=Math.sin(a)*s; this.sz=(Math.random()*2+1) * (1 + intensity * 0.5);
            if (typeof type === 'object') {
                const roll = Math.random() * type.total;
                if (roll < type.fire) { this.c='255,100,0'; if(isRoot) this.vy-=1; }
                else if (roll < type.fire + type.ice) { this.c='100,200,255'; if(isRoot) { this.vy+=0.5; this.sz*=1.5; } }
                else { this.c='200,200,220'; }
            } else {
                if(type==='fire') { this.c='255,100,0'; if(isRoot) this.vy-=1; }
                else if(type==='ice') { this.c='100,200,255'; if(isRoot) { this.vy+=0.5; this.sz*=1.5; } }
                else if(type==='phys') { this.c='220,220,220'; }
                else if(type==='steam') { this.c='216,180,254'; }
                else if(type==='fracture') { this.c='94,234,212'; }
                else if(type==='forge') { this.c='253,230,138'; }
                else this.c='255,215,0';
            }
        }
        update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.015; }
        draw(ctx) { ctx.fillStyle = `rgba(${this.c},${this.life})`; ctx.beginPath(); ctx.arc(this.x,this.y,this.sz,0,6.28); ctx.fill(); }
    }

    class ParticleSystem {
        constructor() { this.p=[]; this.fp=[]; this.r=[]; this.bg=[]; this.ctx=document.getElementById('effects-canvas').getContext('2d'); for(let i=0;i<800;i++)this.bg.push({x:Math.random()*3000,y:Math.random()*3000,s:Math.random()*1.5,a:Math.random(),c:Math.random()>0.9?'#a5f3fc':(Math.random()>0.8?'#fef08a':'#fff')}); }
        spawnRoot(w) { const intensity = window.currentRootIntensity || 0; const chance = 0.3 + (0.6 * intensity); if(Math.random() > chance) return; const count = 2 + Math.floor(intensity * 3); for(let i=0;i<count;i++) this.p.push(new Particle(CENTER, CENTER, w, true)); }
        spawnRipple(x,y,t) { let c=TREES[t]?TREES[t].color:'255,255,255'; if (t==='fire') c='249,115,22'; else if (t==='ice') c='34,211,238'; else if (t==='phys') c='226,232,240'; this.r.push(new Ripple(x,y,c)); }
        spawnFlow() {
            layoutNodes.forEach(node => {
                if(node.id==='root') return;
                (node.data.req||[]).forEach(pid => {
                    if(state.skills[pid]>0 && Math.random()<0.02) {
                        const pn = layoutNodes.find(x=>x.id===pid);
                        if (pn) {
                            let c = TREES[node.data.tree].color;
                            this.fp.push(new FlowParticle(pn.x, pn.y, node.x, node.y, c));
                        }
                    }
                });
            });
            // Modified preview flow logic
            if(hoveredNodeId) {
                const node = layoutNodes.find(n => n.id === hoveredNodeId);
                // Only show flow preview if it's an active or available node (i.e. has connection potential)
                if(node && (state.skills[hoveredNodeId] > 0 || checkRequirements(hoveredNodeId).met)) {
                    // 1. Incoming (Parent -> Me)
                    (node.data.req||[]).forEach(pid => {
                        const pn = layoutNodes.find(n => n.id === pid);
                        if(pn && Math.random() < 0.2) this.fp.push(new FlowParticle(pn.x, pn.y, node.x, node.y, '#fff'));
                    });
                    // 2. Outgoing (Me -> Children)
                    layoutNodes.forEach(child => {
                        if((child.data.req||[]).includes(hoveredNodeId)) {
                            // Only if child is NOT lit (previewing future)
                            if (state.skills[child.id] === 0 && Math.random() < 0.2) {
                                this.fp.push(new FlowParticle(node.x, node.y, child.x, child.y, 'rgba(255,255,255,0.6)'));
                            }
                        }
                    });
                }
            }
        }
        render(t) {
            this.ctx.clearRect(0,0,3000,3000);
            this.bg.forEach(s=>{ this.ctx.fillStyle=s.c; this.ctx.globalAlpha=s.a*(0.6+0.4*Math.sin(t*5+s.x)); this.ctx.beginPath(); this.ctx.arc(s.x,s.y,s.s,0,6.28); this.ctx.fill(); });
            this.ctx.globalAlpha=1;
            this.spawnFlow();
            [this.fp, this.p, this.r].forEach(a=>{ for(let i=a.length-1;i>=0;i--){ a[i].update(); if(a[i].l<=0||a[i].life<=0||a[i].a<=0)a.splice(i,1); else a[i].draw(this.ctx); }});
        }
    }
    const sys = new ParticleSystem();

    function getWeights() {
        let c={fire:0,ice:0,phys:0};
        Object.keys(state.skills).forEach(k=>{
            const n=skillsRaw.find(x=>x.id===k);
            if(n&&state.skills[k]>0) {
                const lvl = state.skills[k];
                if(n.tree==='fire') c.fire += lvl;
                else if(n.tree==='ice') c.ice += lvl;
                else if(n.tree==='phys') c.phys += lvl;
                else if(n.tree==='steam') { c.fire+=0.5*lvl; c.ice+=0.5*lvl; }
                else if(n.tree==='forge') { c.fire+=0.5*lvl; c.phys+=0.5*lvl; }
                else if(n.tree==='fracture') { c.ice+=0.5*lvl; c.phys+=0.5*lvl; }
            }
        });
        const total = c.fire + c.ice + c.phys;
        const maxSpec = Math.max(c.fire, c.ice, c.phys);
        return { ...c, total: total > 0 ? total : 1, maxSpec };
    }

    function updateRootVisuals() {
        const w = getWeights();
        const el = document.querySelector('.node-root');
        if(!el) return;
        let r, g, b;
        if (w.total <= 1) { r=251; g=191; b=36; }
        else {
            r = (w.fire * 249 + w.ice * 34 + w.phys * 226) / w.total;
            g = (w.fire * 115 + w.ice * 211 + w.phys * 232) / w.total;
            b = (w.fire * 22 + w.ice * 238 + w.phys * 240) / w.total;
        }
        const colorStr = `rgb(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)})`;
        const totalIntensity = Math.min(w.total / 50, 1.0);
        const specIntensity = Math.min(w.maxSpec / 20, 1.0);
        const intensity = Math.max(totalIntensity, specIntensity);
        const size = 60 + (40 * intensity);
        el.style.width = `${size}px`; el.style.height = `${size}px`;
        const shadowSize = 20 + (60 * intensity);
        const insetSize = 10 + (20 * intensity);
        el.style.boxShadow = `0 0 ${shadowSize}px ${colorStr}, inset 0 0 ${insetSize}px ${colorStr}`;
        el.style.borderColor = colorStr;
        el.style.opacity = 0.6 + (0.4 * intensity);
        el.style.filter = `brightness(${1 + 0.5 * intensity})`;
        const icon = el.querySelector('svg');
        if(icon) { icon.style.fill = colorStr; icon.style.filter = `drop-shadow(0 0 ${5 + 15 * intensity}px ${colorStr})`; }
        window.currentRootIntensity = intensity;
    }

    function checkRequirements(id) {
        const s = skillsRaw.find(x=>x.id===id);
        if(!s.req || !s.req.length) return {met:true};
        const m = s.req.filter(r => state.skills[r]<1);
        return { met: m.length===0, missingText: m.join(',') };
    }
    function handleSkillClick(id) {
        if(id==='root') return;
        const req = checkRequirements(id);
        if(state.skills[id]>=MAX_LEVEL || !req.met || state.points<=0) return;
        state.points--; state.skills[id]++;
        sys.spawnRipple(layoutNodes.find(n=>n.id===id).x, layoutNodes.find(n=>n.id===id).y, skillsRaw.find(x=>x.id===id).tree);
        render();
    }

    function render() {
        document.getElementById('skill-points-display').innerText = state.points;
        const sl = document.getElementById('skills-layer');
        const cl = document.getElementById('connections-layer');

        if(sl.innerHTML === '') {
            let lH='', nH='';
            layoutNodes.forEach(n => {
                if(n.id!=='root') {
                    (n.data.req||[]).forEach(pid => {
                        const p = layoutNodes.find(x=>x.id===pid);
                        if(p) {
                            const isHybrid = !['fire','ice','phys','root'].includes(n.data.tree);
                            const cls = isHybrid ? 'connection-line line-hybrid' : 'connection-line line-locked';
                            lH += `<path id="line-${pid}-${n.id}" d="M ${p.x} ${p.y} L ${n.x} ${n.y}" class="${cls}" />`;
                        }
                    });
                }
                const sz = n.id==='root'?60:40;
                nH += `<div id="node-${n.id}" class="skill-node node-${n.data.tree} ${n.id==='root'?'node-root':''}" style="width:${sz}px; height:${sz}px; left:${n.x-sz/2}px; top:${n.y-sz/2}px;" onclick="handleSkillClick('${n.id}')" onmouseenter="hoverNode('${n.id}',true)" onmouseleave="hoverNode('${n.id}',false)"><svg viewBox="0 0 24 24"><path d="${ICONS[n.data.icon]||ICONS.spark}"/></svg>${n.id!=='root'?`<div class="level-badge">0/3</div>`:''}</div>`;
            });
            cl.innerHTML = lH; sl.innerHTML = nH;
        }
        layoutNodes.forEach(n => {
            if(n.id==='root')return; const el=document.getElementById(`node-${n.id}`); const lvl=state.skills[n.id]; const req=checkRequirements(n.id);
            el.className=`skill-node node-${n.data.tree}`;
            if(lvl>0){el.classList.add('node-active');if(lvl>=MAX_LEVEL)el.classList.add('node-maxed');} else if(req.met&&state.points>0)el.classList.add('node-available'); else el.classList.add('node-locked');
            el.querySelector('.level-badge').innerText=`${lvl}/${MAX_LEVEL}`;
            (n.data.req||[]).forEach(pid => {
                const line = document.getElementById(`line-${pid}-${n.id}`);
                if (line) {
                    const pLvl = state.skills[pid];
                    const color = TREES[n.data.tree].color;
                    const isHybrid = !['fire','ice','phys','root'].includes(n.data.tree);
                    line.setAttribute('class', isHybrid ? 'connection-line line-hybrid' : 'connection-line');
                    line.style.stroke = '';
                    if(lvl>0) { line.classList.add('line-active'); line.style.stroke = color; }
                    else if(pLvl>0 && !isHybrid) line.classList.add('line-available');
                    else if(!isHybrid) line.classList.add('line-locked');
                }
            });
        });
        updateRootVisuals();
    }

    // ---- New Focus Logic ----
    function hoverNode(id, h) {
        hoveredNodeId = h ? id : null;
        const el=document.getElementById(`node-${id}`);
        const req = checkRequirements(id);
        const isAvailable = req.met || state.skills[id] > 0;

        if(h){
            el.classList.add('is-hovered');
            showTooltip(layoutNodes.find(x=>x.id===id));

            // FOCUS MODE Logic
            if (isAvailable) {
                // 1. Calculate relevant set
                const ancestors = getAncestors(id);
                const directUnlitChildren = getDirectUnlitChildren(id);

                // 2. Iterate all elements and apply dimmed
                layoutNodes.forEach(n => {
                    // Don't dim if it's the node itself, an ancestor, or a direct target child
                    if (n.id !== id && !ancestors.has(n.id) && !directUnlitChildren.has(n.id)) {
                        const nEl = document.getElementById(`node-${n.id}`);
                        if(nEl) nEl.classList.add('is-dimmed');
                    }
                });

                // 3. Dim lines
                // A line is relevant if it connects two relevant nodes?
                // Actually, lines connecting ancestors are relevant.
                // Lines connecting to children are relevant.
                document.querySelectorAll('.connection-line').forEach(line => {
                    // Check IDs from line ID "line-ParentID-ChildID"
                    const parts = line.id.split('-');
                    const pId = parts[1];
                    const cId = parts[2];

                    // Keep if:
                    // (Parent is Ancestor AND Child is Ancestor) -- Path up
                    // (Parent is Ancestor AND Child is Hovered) -- Incoming link
                    // (Parent is Hovered AND Child is DirectChild) -- Outgoing link
                    const pRel = ancestors.has(pId);
                    const cRel = ancestors.has(cId); // Hovered is in ancestors set technically for set logic, but let's be explicit
                    const pIsHover = pId === id;
                    const cIsHover = cId === id;
                    const cIsChild = directUnlitChildren.has(cId);

                    const relevant = (pRel && (cRel || cIsHover)) || (pIsHover && cIsChild);

                    if (!relevant) line.classList.add('is-dimmed');
                });
            }

        } else {
            el.classList.remove('is-hovered');
            document.getElementById('tooltip').style.display='none';

            // Reset Dimmed
            document.querySelectorAll('.is-dimmed').forEach(e => e.classList.remove('is-dimmed'));
        }
    }

    function getAncestors(nodeId, visited = new Set()) {
        if (visited.has(nodeId)) return visited;
        visited.add(nodeId);
        const node = skillsRaw.find(n => n.id === nodeId);
        if (!node) return visited;
        (node.req || []).forEach(pid => getAncestors(pid, visited));
        return visited;
    }

    function getDirectUnlitChildren(nodeId) {
        const childrenIds = new Set();
        skillsRaw.forEach(n => {
            if ((n.req || []).includes(nodeId) && state.skills[n.id] === 0) {
                childrenIds.add(n.id);
            }
        });
        return childrenIds;
    }

    function showTooltip(n) {
        const tt=document.getElementById('tooltip'); const lvl=state.skills[n.id];
        tt.querySelector('#tt-name').innerText=n.data.name; tt.querySelector('#tt-desc').innerText=n.data.desc; tt.querySelector('#tt-rank').innerText=`${lvl}/3`;
        tt.style.display='block'; const el=document.getElementById(`node-${n.id}`); const r=el.getBoundingClientRect(); tt.style.left=(r.right+10)+'px'; tt.style.top=r.top+'px';
    }
    function autoUnlock() { Object.keys(state.skills).forEach(k=>{if(Math.random()>0.6&&k!=='root')state.skills[k]=1;}); render(); }
    function resetTree() { state.points=100; for(let k in state.skills)if(k!=='root')state.skills[k]=0; render(); }
    window.onload = () => {
        const vp = document.getElementById('viewport'); vp.scrollLeft=(CANVAS_SIZE-window.innerWidth)/2; vp.scrollTop=(CANVAS_SIZE-window.innerHeight)/2;
        precomputeLayout();
        let d=false, sx, sy, sl, st;
        vp.onmousedown=e=>{d=true;sx=e.pageX-vp.offsetLeft;sy=e.pageY-vp.offsetTop;sl=vp.scrollLeft;st=vp.scrollTop;};
        window.onmouseup=()=>d=false; window.onmousemove=e=>{if(d){e.preventDefault();vp.scrollLeft=sl-(e.pageX-vp.offsetLeft-sx);vp.scrollTop=st-(e.pageY-vp.offsetTop-sy);}};
        function loop(t) {
            const weights = getWeights();
            sys.spawnRoot(weights);
            sys.render(t/1000); requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);
    };
</script>
</body>
</html>