---
title: "[Instant NGP Code Digest - A First Principle Perspective] PCG: Permuted Congruential Generator"
published: 2025-11-28
description: 'What is PCG (Permuted Congruential Generator) and how to implement it from scratch?'
image: ''
tags: [ NeRF/NGP, Probability ]
category: 'Graphics'
draft: false
lang: 'en'
---

:::tip[UPDATE LOG]
- [x] PCG Implementation (2025-11-28)
- [x] PCG Definition (2025-11-28)
- [x] PCG Motivation (2025-11-28)
  :::

# 1. Why Introduce PCG?

Most random number generators in widespread use today have one of the following problems: [[1]](https://www.pcg-random.org/)

- [Not Actually Random](https://www.pcg-random.org/statistical-tests.html)
- [Predictable & Insecure](https://www.pcg-random.org/predictability.html)
- [Mediocre Performance](https://www.pcg-random.org/rng-performance.html)
- [Lack Useful Features](https://www.pcg-random.org/useful-features.html)

| RNG Family         | Statistical Quality | Prediction Difficulty | Reproducible Results | Multiple Streams | Period               | Useful Features           | Time Performance | Space Usage    | Code Size & Complexity | k-Dimensional Equidistribution |
|-------------------|--------------------|----------------------|----------------------|------------------|----------------------|---------------------------|------------------|----------------|------------------------|-------------------------------|
| **PCG Family**    | ğŸŸ¢ Excellent       | ğŸŸ¢ Challenging       | ğŸŸ¢ Yes               | ğŸŸ¢ Yes (2^63)    | ğŸŸ¢ Arbitrary         | ğŸŸ¢ Jump ahead, Distance    | ğŸŸ¢ Very fast     | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸŸ¢ Arbitrary*                 |
| Mersenne Twister  | ğŸŸ¡ Some Failures   | ğŸ”´ Easy              | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸŸ¢ Huge (2^19937)    | ğŸŸ¡ Jump ahead             | ğŸŸ¡ Acceptable    | ğŸŸ¡ Huge (2 KB) | ğŸŸ¡ Complex              | ğŸŸ¢ 623                       |
| Arc4Random        | ğŸŸ¡ Some Issues     | ğŸŸ¢ Secure            | ğŸŸ¡ Not Always        | ğŸ”´ No            | ğŸŸ¢ Huge (2^1699)     | ğŸ”´ No                    | ğŸ”´ Slow          | ğŸŸ¡ Large (0.5 KB) | ğŸŸ¡ Complex           | ğŸ”´ No                        |
| ChaCha20â€          | ğŸŸ¢ Good            | ğŸŸ¢ Secure            | ğŸŸ¢ Yes               | ğŸŸ¢ Yes (2^128)   | ğŸŸ¢ 2^128             | ğŸŸ¢ Jump ahead, Distance    | ğŸ”´ Fairly Slow   | ğŸŸ¡ Plump (0.1 KB) | ğŸŸ¡ Complex         | ğŸ”´ No                        |
| Minstd (LCG)      | ğŸ”´ Many Issues     | ğŸ”´ Trivial           | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸ”´ Tiny < 2^32       | ğŸŸ¢ Jump ahead, Distance    | ğŸŸ¡ Acceptable    | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |
| LCG 64/32         | ğŸ”´ Many Issues     | ğŸŸ¡ Published Algos   | ğŸŸ¢ Yes               | ğŸŸ¢ Yes 2^63      | ğŸŸ¢ Okay 2^64        | ğŸŸ¢ Jump ahead, Distance    | ğŸŸ¢ Very fast     | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |
| XorShift 32       | ğŸ”´ Many Issues     | ğŸ”´ Trivial           | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸ”´ Small 2^32       | ğŸŸ¡ Jump ahead             | ğŸŸ¢ Fast          | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |
| XorShift 64       | ğŸ”´ Many Issues     | ğŸ”´ Trivial           | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸŸ¢ Okay 2^64        | ğŸŸ¡ Jump ahead             | ğŸŸ¢ Fast          | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |
| RanQ              | ğŸŸ¡ Some Issues     | ğŸ”´ Trivial           | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸŸ¢ Okay 2^64        | ğŸŸ¡ Jump ahead             | ğŸŸ¢ Fast          | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |
| XorShift* 64/32   | ğŸŸ¢ Excellent       | ğŸŸ¡ Unknown?          | ğŸŸ¢ Yes               | ğŸ”´ No            | ğŸŸ¢ Okay 2^64        | ğŸŸ¡ Jump ahead             | ğŸŸ¢ Fast          | ğŸŸ¢ Very compact | ğŸŸ¢ Very small           | ğŸ”´ No                        |

---

# 2. What is PCG? Learn PCG from Scratch

## 2.1 The foundation: LCG [[2]](https://en.wikipedia.org/wiki/Linear_congruential_generator)

The most basic PRNG [[3]](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) uses this recurrence:

$$
x_{n+1} = (a x_n + c) \bmod 2^{64}
$$

This is only integer modular arithmetic. $x_n = \text{internal hidden state}$.

It is fast, but it has **huge weaknesses**:

| Problem                        | Why                                        |
| ------------------------------ | ------------------------------------------ |
| Poor randomness                | Bits are highly correlated                 |
| Easy to predict                | Given a few outputs â†’ recover the sequence |
| Low quality high-order entropy | Top bits & bottom bits are uneven          |

**PCG starts from this formula**, but enhances it.

## 2.2 PCG = LCG + Permutation

### Key idea:

> Instead of returning the state directly, apply a *randomizing permutation* to it.

$$
\text{output} = \Pi\big(x_{n}\big)
$$

where $\Pi$ scrambles bits to break patterns.

So PCG is:

$$
x_{n+1} = (a x_n + c) \bmod 2^{64} \quad \text{(LCG update)}
$$
$$
y_n = \text{permute}(x_n) \quad \text{(XSH-RR bit scramble)}
$$

PCG doesnâ€™t rely on a stronger LCGâ€”
**it relies on a brilliant output function.**

### Permutation in PCG

Key properties we want of this permutation:

| Property                     | Meaning                                           |
| ---------------------------- | ------------------------------------------------- |
| bijective                    | every 64-bit input maps to a unique 64-bit output |
| nonlinear                    | breaks the linear structure of LCG outputs        |
| statistically strong         | spreads entropy across bits                       |
| predictable only with effort | increases difficulty of state recovery            |

The specific permutation used in **PCG-XSH-RR** (the standard version) is a combination of **XOR-shift**, **high-bit extraction**, and a **data-dependent bit rotation**:

#### Step 1 â€” XOR-Shift (XSH)

Mix the state with a shifted copy of itself:

$$
z = x_n \oplus (x_n \gg 18)
$$
$$
z = z \gg 27
$$

This step reduces 64-bit state to a scrambled 32-bit value while blending high bits into low bits â€” eliminating weak low-bit structure of raw LCG.
#### Step 2 â€” Random Rotate (RR)

Compute a rotation amount using the high bits of the state:

$$
r = x_n \gg 59
$$

Then rotate the previous output value right by that amount:

$$
y_n = (z \gg r) ;\big|; (z \ll (32-r))
$$

This rotation is **state-dependent**, meaning *each output is shuffled differently*.

## 3. PCG: From Theory to Implementation

### 3.1 Precise Definition

Using everything above, we can now define a PCG generator *precisely*. [[4]](https://en.wikipedia.org/wiki/Permuted_congruential_generator)

A **PCG generator** is fully determined by two components:

1. **State transition function**  (LCG core)
2. **Output permutation function**  (scrambler)

Formally:

$$
\boxed{
\begin{aligned}
x_{n+1} &= (a x_n + c) \bmod 2^{64} \\
y_n &= \Pi(x_n)
\end{aligned}
}
$$

Where:

| Symbol         | Meaning                                           |
| -------------- | ------------------------------------------------- |
| $ x_n $        | 64-bit internal state (never returned directly)   |
| $ a $          | multiplier constant, odd, fixed per RNG instance  |
| $ c $          | increment constant (stream selector), must be odd |
| $ \Pi(\cdot) $ | output permutation for statistical quality        |
| $ y_n $        | the returned random number                        |

This structure is *modular*:
any LCG + any permutation = a PCG variant.

The most common and recommended version is **PCG-XSH-RR 64/32**
â†’ 64-bit state, produces 32-bit outputs.

### 3.2 Official PCG-XSH-RR Output Function

$$
\Pi(x) = \text{ROR}\big((x \oplus (x \gg 18)) \gg 27, ; x \gg 59 \big)
$$

Expanded step-by-step:

| Step                   | Operation                    |
| ---------------------- | ---------------------------- |
| $t = x \gg 18$         | extract high bits            |
| $t = x \oplus t$       | mix entropy (XOR-shift)      |
| $z = t \gg 27$         | compress to 32 bits          |
| $r = x \gg 59$         | derive rotation amount       |
| $y = \text{ROR}(z, r)$ | final non-linear permutation |

Result:

$$
\boxed{y_n = \text{ROR}\Big(\big(x_n \oplus (x_n \gg 18)\big) \gg 27,\ x_n \gg 59\Big)}
$$

This is the heart of PCG.

### 3.3 Official Reference Implementation (C++)

```cpp
uint32_t pcg32_random_r(uint64_t& state, uint64_t inc) {
    uint64_t old = state;
    state = old * 6364136223846793005ULL + (inc | 1ULL);

    uint32_t xorshifted = ((old >> 18u) ^ old) >> 27u;
    uint32_t rot = old >> 59u;

    return (xorshifted >> rot) | (xorshifted << ((32 - rot) & 31));
}
```

#### Notes:

* `state` evolves using **LCG step**
* `xorshifted` implements the **XSH** algorithm
* `rot` comes from the **59 highest bits**
* final line is the **RR rotation** â†’ the output

This is *exactly* the formula we defined above.

# Reference

1. https://www.pcg-random.org/
2. https://en.wikipedia.org/wiki/Linear_congruential_generator
3. https://en.wikipedia.org/wiki/Pseudorandom_number_generator
4. https://en.wikipedia.org/wiki/Permuted_congruential_generator